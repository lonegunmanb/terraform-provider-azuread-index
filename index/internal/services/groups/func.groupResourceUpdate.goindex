package github.com/hashicorp/terraform-provider-azuread/internal/services/groups
import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"reflect"
	"regexp"
	"slices"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/common-types/beta"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/common-types/stable"
	administrativeunitmemberBeta "github.com/hashicorp/go-azure-sdk/microsoft-graph/directory/beta/administrativeunitmember"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/directoryobjects/stable/directoryobject"
	groupBeta "github.com/hashicorp/go-azure-sdk/microsoft-graph/groups/beta/group"
	memberBeta "github.com/hashicorp/go-azure-sdk/microsoft-graph/groups/beta/member"
	memberofBeta "github.com/hashicorp/go-azure-sdk/microsoft-graph/groups/beta/memberof"
	ownerBeta "github.com/hashicorp/go-azure-sdk/microsoft-graph/groups/beta/owner"
	"github.com/hashicorp/go-azure-sdk/sdk/nullable"
	"github.com/hashicorp/go-azure-sdk/sdk/odata"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-provider-azuread/internal/clients"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/consistency"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf/validation"
	"github.com/hashicorp/terraform-provider-azuread/internal/services/groups/migrations"
)
func groupResourceUpdate(ctx context.Context, d *pluginsdk.ResourceData, meta interface{}) pluginsdk.Diagnostics {
	client := meta.(*clients.Client).Groups.GroupClientBeta
	ownerClient := meta.(*clients.Client).Groups.GroupOwnerClientBeta
	memberClient := meta.(*clients.Client).Groups.GroupMemberClientBeta
	memberOfClient := meta.(*clients.Client).Groups.GroupMemberOfClientBeta
	administrativeUnitMemberClient := meta.(*clients.Client).Groups.AdministrativeUnitMemberClientBeta

	id, err := beta.ParseGroupID(d.Id())
	if err != nil {
		return tf.ErrorDiagPathF(err, "id", "Parsing ID")
	}

	callerId := meta.(*clients.Client).ObjectID
	displayName := d.Get("display_name").(string)

	tf.LockByName(groupResourceName, id.GroupId)
	defer tf.UnlockByName(groupResourceName, id.GroupId)

	// Perform this check at apply time to catch any duplicate names created during the same apply
	if d.Get("prevent_duplicate_names").(bool) {
		result, err := groupFindByName(ctx, client, displayName)
		if err != nil {
			return tf.ErrorDiagPathF(err, "display_name", "Could not check for existing group(s)")
		}
		if result != nil && len(*result) > 0 {
			for _, existingGroup := range *result {
				if existingGroup.Id == nil {
					return tf.ErrorDiagF(errors.New("API returned group with nil object ID during duplicate name check"), "Bad API response")
				}

				if *existingGroup.Id != id.GroupId {
					return tf.ImportAsDuplicateDiag("azuread_group", *existingGroup.Id, displayName)
				}
			}
		}
	}

	group := beta.Group{
		Description:     nullable.NoZero(d.Get("description").(string)),
		DisplayName:     nullable.Value(displayName),
		MailEnabled:     nullable.Value(d.Get("mail_enabled").(bool)),
		MembershipRule:  nullable.NoZero(""),
		SecurityEnabled: nullable.Value(d.Get("security_enabled").(bool)),
	}

	if d.HasChange("writeback_enabled") || d.HasChange("onpremises_group_type") {
		group.WritebackConfiguration = &beta.GroupWritebackConfiguration{
			IsEnabled:              nullable.Value(d.Get("writeback_enabled").(bool)),
			OmitDiscriminatedValue: true,
		}
		if onPremisesGroupType := d.Get("onpremises_group_type").(string); onPremisesGroupType != "" {
			group.WritebackConfiguration.OnPremisesGroupType = nullable.Value(onPremisesGroupType)
		}
	}

	if v, ok := d.GetOk("dynamic_membership"); ok && len(v.([]interface{})) > 0 {
		if d.Get("dynamic_membership.0.enabled").(bool) {
			group.MembershipRuleProcessingState = nullable.Value("On")
		} else {
			group.MembershipRuleProcessingState = nullable.Value("Paused")
		}

		group.MembershipRule = nullable.Value(d.Get("dynamic_membership.0.rule").(string))
	}

	if theme := d.Get("theme").(string); theme != "" {
		group.Theme = nullable.Value(theme)
	}

	if d.HasChange("visibility") {
		group.Visibility = nullable.Value(d.Get("visibility").(string))
	}

	if _, err := client.UpdateGroup(ctx, *id, group, groupBeta.DefaultUpdateGroupOperationOptions()); err != nil {
		return tf.ErrorDiagF(err, "Updating %s", id)
	}

	groupTypes := make([]string, 0)
	for _, v := range d.Get("types").(*pluginsdk.Set).List() {
		groupTypes = append(groupTypes, v.(string))
	}

	// The following properties can only be set or unset for Unified groups, other group types will return a 4xx error.
	if slices.Contains(groupTypes, GroupTypeUnified) {
		// The unified group properties in this block only support delegated auth
		// Application-authenticated requests will return a 403 or 404 error, so we
		// only set these when explicitly configured, and when the value differs.
		// See https://docs.microsoft.com/en-us/graph/known-issues#groups
		extra, err := groupGetAdditional(ctx, client, *id)
		if err != nil {
			return tf.ErrorDiagF(err, "Retrieving extra fields for %s", id)
		}

		// AllowExternalSenders can only be set in its own PATCH request; including other properties returns a 400
		if v, ok := d.GetOkExists("external_senders_allowed"); ok && (extra == nil || extra.AllowExternalSenders.GetOrZero() != v.(bool)) { //nolint:staticcheck
			if _, err = client.UpdateGroup(ctx, *id, beta.Group{
				AllowExternalSenders: nullable.Value(v.(bool)),
			}, groupBeta.DefaultUpdateGroupOperationOptions()); err != nil {
				return tf.CheckDelegatedAuthDiagF(err, "Failed to set `external_senders_allowed` for %s", id)
			}

			// Wait for AllowExternalSenders to be updated
			if err = consistency.WaitForUpdate(ctx, func(ctx context.Context) (*bool, error) {
				groupExtra, err := groupGetAdditional(ctx, client, *id)
				if err != nil {
					return nil, err
				}
				return pointer.To(groupExtra != nil && groupExtra.AllowExternalSenders.GetOrZero() == v.(bool)), nil
			}); err != nil {
				return tf.ErrorDiagF(err, "Waiting for update of `external_senders_allowed` for %s", id)
			}
		}

		// AutoSubscribeNewMembers can only be set in its own PATCH request; including other properties returns a 400
		if v, ok := d.GetOkExists("auto_subscribe_new_members"); ok && (extra == nil || extra.AutoSubscribeNewMembers.GetOrZero() != v.(bool)) { //nolint:staticcheck
			if _, err = client.UpdateGroup(ctx, *id, beta.Group{
				AutoSubscribeNewMembers: nullable.Value(v.(bool)),
			}, groupBeta.DefaultUpdateGroupOperationOptions()); err != nil {
				return tf.CheckDelegatedAuthDiagF(err, "Failed to set `auto_subscribe_new_members` for %s", id)
			}

			// Wait for AutoSubscribeNewMembers to be updated
			if err = consistency.WaitForUpdate(ctx, func(ctx context.Context) (*bool, error) {
				groupExtra, err := groupGetAdditional(ctx, client, *id)
				if err != nil {
					return nil, err
				}
				return pointer.To(groupExtra != nil && groupExtra.AutoSubscribeNewMembers.GetOrZero() == v.(bool)), nil
			}); err != nil {
				return tf.ErrorDiagF(err, "Waiting for update of `auto_subscribe_new_members` for %s", id)
			}
		}

		// HideFromAddressLists can only be set in its own PATCH request; including other properties returns a 400
		if v, ok := d.GetOkExists("hide_from_address_lists"); ok && (extra == nil || extra.HideFromAddressLists.GetOrZero() != v.(bool)) { //nolint:staticcheck
			if _, err = client.UpdateGroup(ctx, *id, beta.Group{
				HideFromAddressLists: nullable.Value(v.(bool)),
			}, groupBeta.DefaultUpdateGroupOperationOptions()); err != nil {
				return tf.CheckDelegatedAuthDiagF(err, "Failed to set `hide_from_address_lists` for %s", id)
			}

			// Wait for HideFromAddressLists to be updated
			if err = consistency.WaitForUpdate(ctx, func(ctx context.Context) (*bool, error) {
				groupExtra, err := groupGetAdditional(ctx, client, *id)
				if err != nil {
					return nil, err
				}
				return pointer.To(groupExtra != nil && groupExtra.HideFromAddressLists.GetOrZero() == v.(bool)), nil
			}); err != nil {
				return tf.ErrorDiagF(err, "Waiting for update of `hide_from_address_lists` for %s", id)
			}
		}

		// HideFromOutlookClients can only be set in its own PATCH request; including other properties returns a 400
		if v, ok := d.GetOkExists("hide_from_outlook_clients"); ok && (extra == nil || extra.HideFromOutlookClients.GetOrZero() != v.(bool)) { //nolint:staticcheck
			if _, err = client.UpdateGroup(ctx, *id, beta.Group{
				HideFromOutlookClients: nullable.Value(v.(bool)),
			}, groupBeta.DefaultUpdateGroupOperationOptions()); err != nil {
				return tf.CheckDelegatedAuthDiagF(err, "Failed to set `hide_from_outlook_clients` for %s", id)
			}

			// Wait for HideFromOutlookClients to be updated
			if err = consistency.WaitForUpdate(ctx, func(ctx context.Context) (*bool, error) {
				groupExtra, err := groupGetAdditional(ctx, client, *id)
				if err != nil {
					return nil, err
				}
				return pointer.To(groupExtra != nil && groupExtra.HideFromOutlookClients.GetOrZero() == v.(bool)), nil
			}); err != nil {
				return tf.ErrorDiagF(err, "Waiting for update of `hide_from_outlook_clients` for %s", id)
			}
		}
	}

	if d.HasChange("members") {
		resp, err := memberClient.ListMembers(ctx, *id, memberBeta.DefaultListMembersOperationOptions())
		if err != nil {
			return tf.ErrorDiagF(err, "Could not retrieve members for %s", id)
		}

		existingMembers := make([]string, 0)
		if resp.Model != nil {
			for _, m := range *resp.Model {
				existingMembers = append(existingMembers, pointer.From(m.DirectoryObject().Id))
			}
		}

		desiredMembers := *tf.ExpandStringSlicePtr(d.Get("members").(*pluginsdk.Set).List())
		membersForRemoval := tf.Difference(existingMembers, desiredMembers)
		membersToAdd := tf.Difference(desiredMembers, existingMembers)

		for _, v := range membersForRemoval {
			memberId := beta.NewGroupIdMemberID(id.GroupId, v)
			if _, err = memberClient.RemoveMemberRef(ctx, memberId, memberBeta.DefaultRemoveMemberRefOperationOptions()); err != nil {
				return tf.ErrorDiagF(err, "removing %s", memberId)
			}
		}

		for _, v := range membersToAdd {
			ref := beta.ReferenceCreate{
				ODataId: pointer.To(client.Client.BaseUri + beta.NewDirectoryObjectID(v).ID()),
			}
			if _, err = memberClient.AddMemberRef(ctx, *id, ref, memberBeta.DefaultAddMemberRefOperationOptions()); err != nil {
				return tf.ErrorDiagF(err, "removing %s", beta.NewGroupIdMemberID(id.GroupId, v))
			}
		}
	}

	if v, ok := d.GetOk("owners"); ok && d.HasChange("owners") {
		resp, err := ownerClient.ListOwners(ctx, *id, ownerBeta.DefaultListOwnersOperationOptions())
		if err != nil {
			return tf.ErrorDiagF(err, "Could not retrieve members for %s", id)
		}

		// If all owners are removed, restore the calling principal as the sole owner, in order to meet API
		// restrictions about removing all owners, and maintain consistency with the Create behaviour.
		// In theory this path should never be reached, since the property is Computed and has MinItems: 1, but we handle it anyway.
		desiredOwners := tf.ExpandStringSlice(v.(*pluginsdk.Set).List())
		if len(desiredOwners) == 0 {
			desiredOwners = []string{callerId}
		}

		existingOwners := make([]string, 0)
		if resp.Model != nil {
			for _, o := range *resp.Model {
				existingOwners = append(existingOwners, pointer.From(o.DirectoryObject().Id))
			}
		}

		ownersForRemoval := tf.Difference(existingOwners, desiredOwners)
		ownersToAdd := tf.Difference(desiredOwners, existingOwners)

		// Add new owners first to avoid leaving the group without any owners
		for _, v := range ownersToAdd {
			ref := beta.ReferenceCreate{
				ODataId: pointer.To(client.Client.BaseUri + beta.NewDirectoryObjectID(v).ID()),
			}
			if _, err = ownerClient.AddOwnerRef(ctx, *id, ref, ownerBeta.DefaultAddOwnerRefOperationOptions()); err != nil {
				return tf.ErrorDiagF(err, "removing %s", beta.NewGroupIdOwnerID(id.GroupId, v))
			}
		}

		for _, v := range ownersForRemoval {
			ownerId := beta.NewGroupIdOwnerID(id.GroupId, v)
			if _, err = ownerClient.RemoveOwnerRef(ctx, ownerId, ownerBeta.DefaultRemoveOwnerRefOperationOptions()); err != nil {
				return tf.ErrorDiagF(err, "removing %s", ownerId)
			}
		}
	}

	if v := d.Get("administrative_unit_ids"); d.HasChange("administrative_unit_ids") {
		resp, err := memberOfClient.ListMemberOfs(ctx, *id, memberofBeta.DefaultListMemberOfsOperationOptions())
		if err != nil {
			return tf.ErrorDiagPathF(err, "administrative_units", "retrieving administrative unit memberships for %s", id)
		}

		if resp.Model == nil {
			return tf.ErrorDiagPathF(errors.New("model was nil"), "administrative_units", "retrieving administrative unit memberships for %s", id)
		}

		var existingAdministrativeUnits []string
		for _, obj := range *resp.Model {
			if _, ok := obj.(beta.AdministrativeUnit); ok {
				existingAdministrativeUnits = append(existingAdministrativeUnits, *obj.DirectoryObject().Id)
			}
		}

		desiredAdministrativeUnits := tf.ExpandStringSlice(v.(*pluginsdk.Set).List())
		administrativeUnitsToLeave := tf.Difference(existingAdministrativeUnits, desiredAdministrativeUnits)
		administrativeUnitsToJoin := tf.Difference(desiredAdministrativeUnits, existingAdministrativeUnits)

		if len(administrativeUnitsToJoin) > 0 {
			for _, v := range administrativeUnitsToJoin {
				newAdministrativeUnitId := beta.NewDirectoryAdministrativeUnitID(v)
				ref := beta.ReferenceCreate{
					ODataId: pointer.To(fmt.Sprintf("%s%s", client.Client.BaseUri, beta.NewDirectoryObjectID(id.GroupId).ID())),
				}
				if _, err = administrativeUnitMemberClient.AddAdministrativeUnitMemberRef(ctx, newAdministrativeUnitId, ref, administrativeunitmemberBeta.DefaultAddAdministrativeUnitMemberRefOperationOptions()); err != nil {
					return tf.ErrorDiagF(err, "Could not add %s as member of %s", id, newAdministrativeUnitId)
				}
			}
		}

		if len(administrativeUnitsToLeave) > 0 {
			for _, v := range administrativeUnitsToLeave {
				memberId := beta.NewDirectoryAdministrativeUnitIdMemberID(v, id.GroupId)
				if _, err = administrativeUnitMemberClient.RemoveAdministrativeUnitMemberRef(ctx, memberId, administrativeunitmemberBeta.DefaultRemoveAdministrativeUnitMemberRefOperationOptions()); err != nil {
					return tf.ErrorDiagF(err, "Could not remove %s", memberId)
				}
			}
		}
	}

	return groupResourceReadFunc(false)(ctx, d, meta)
}
