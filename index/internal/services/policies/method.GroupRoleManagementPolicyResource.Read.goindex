package github.com/hashicorp/terraform-provider-azuread/internal/services/policies
import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-sdk/sdk/odata"
	"github.com/hashicorp/terraform-provider-azuread/internal/sdk"
	"github.com/hashicorp/terraform-provider-azuread/internal/services/policies/parse"
	"github.com/hashicorp/terraform-provider-azuread/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azuread/internal/tf/validation"
	"github.com/manicminer/hamilton/msgraph"
)
func (r GroupRoleManagementPolicyResource) Read() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 5 * time.Minute,
		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			clientPolicy := metadata.Client.Policies.RoleManagementPolicyClient
			clientAssignment := metadata.Client.Policies.RoleManagementPolicyAssignmentClient

			id, err := parse.ParseRoleManagementPolicyID(metadata.ResourceData.Id())
			if err != nil {
				return fmt.Errorf("could not parse policy ID, %+v", err)
			}

			var model GroupRoleManagementPolicyModel
			if err := metadata.Decode(&model); err != nil {
				return fmt.Errorf("decoding: %+v", err)
			}

			result, _, err := clientPolicy.Get(ctx, id.ID())
			if err != nil {
				return fmt.Errorf("retrieving %s: %+v", id, err)
			}
			if result == nil {
				return fmt.Errorf("retrieving %s: API error, result was nil", id)
			}

			assignments, _, err := clientAssignment.List(ctx, odata.Query{
				Filter: fmt.Sprintf("scopeType eq 'Group' and scopeId eq '%s' and policyId eq '%s'", id.ScopeId, id.ID()),
			})
			if err != nil {
				return fmt.Errorf("retrieving %s: %+v", id, err)
			}
			if assignments == nil {
				return fmt.Errorf("retrieving %s: expected 1 assignment, got nil result", id)
			}
			if len(*assignments) != 1 {
				return fmt.Errorf("retrieving %s: expected 1 assignment, got %d", id, len(*assignments))
			}

			model.Description = pointer.From(result.Description)
			model.DisplayName = pointer.From(result.DisplayName)
			model.GroupId = pointer.From(result.ScopeId)
			model.RoleId = pointer.From((*assignments)[0].RoleDefinitionId)

			if len(model.EligibleAssignmentRules) == 0 {
				model.EligibleAssignmentRules = make([]GroupRoleManagementPolicyEligibleAssignmentRules, 1)
			}
			if len(model.ActiveAssignmentRules) == 0 {
				model.ActiveAssignmentRules = make([]GroupRoleManagementPolicyActiveAssignmentRules, 1)
			}
			if len(model.ActivationRules) == 0 {
				model.ActivationRules = make([]GroupRoleManagementPolicyActivationRules, 1)
			}
			if len(model.NotificationRules) == 0 {
				model.NotificationRules = make([]GroupRoleManagementPolicyNotificationEvents, 1)
			}
			if len(model.NotificationRules[0].EligibleActivations) == 0 {
				model.NotificationRules[0].EligibleActivations = make([]GroupRoleManagementPolicyNotificationRule, 1)
			}
			if len(model.NotificationRules[0].ActiveAssignments) == 0 {
				model.NotificationRules[0].ActiveAssignments = make([]GroupRoleManagementPolicyNotificationRule, 1)
			}
			if len(model.NotificationRules[0].EligibleAssignments) == 0 {
				model.NotificationRules[0].EligibleAssignments = make([]GroupRoleManagementPolicyNotificationRule, 1)
			}

			if result.Rules != nil {
				for _, rule := range *result.Rules {
					switch pointer.From(rule.ID) {
					case "Approval_EndUser_Assignment":
						model.ActivationRules[0].RequireApproval = pointer.From(rule.Setting.IsApprovalRequired)

						primaryApprovers := make([]GroupRoleManagementPolicyApprover, 0)

						if rule.Setting != nil && rule.Setting.ApprovalStages != nil {
							if approvers := (*rule.Setting.ApprovalStages)[0].PrimaryApprovers; approvers != nil {
								for _, approver := range *approvers {
									switch {
									case pointer.From(approver.ODataType) == "#microsoft.graph.singleUser":
										primaryApprovers = append(primaryApprovers, GroupRoleManagementPolicyApprover{
											ID:   pointer.ToString(approver.UserID),
											Type: "singleUser",
										})
									case pointer.From(approver.ODataType) == "#microsoft.graph.groupMembers":
										primaryApprovers = append(primaryApprovers, GroupRoleManagementPolicyApprover{
											ID:   pointer.ToString(approver.GroupID),
											Type: "groupMembers",
										})
									default:
										return fmt.Errorf("unknown approver type: %s", *approver.ODataType)
									}
								}
							}
						}

						model.ActivationRules[0].ApprovalStages = []GroupRoleManagementPolicyApprovalStage{{PrimaryApprovers: primaryApprovers}}

					case "AuthenticationContext_EndUser_Assignment":
						if rule.ClaimValue != nil && *rule.ClaimValue != "" {
							model.ActivationRules[0].RequireConditionalAccessContext = *rule.ClaimValue
						}

					case "Enablement_Admin_Assignment":
						model.ActiveAssignmentRules[0].RequireMultiFactorAuth = false
						model.ActiveAssignmentRules[0].RequireJustification = false

						if enabledRules := rule.EnabledRules; enabledRules != nil {
							for _, enabledRule := range *enabledRules {
								switch enabledRule {
								case "MultiFactorAuthentication":
									model.ActiveAssignmentRules[0].RequireMultiFactorAuth = true
								case "Justification":
									model.ActiveAssignmentRules[0].RequireJustification = true
								}
							}
						}

					case "Enablement_EndUser_Assignment":
						model.ActivationRules[0].RequireMultiFactorAuth = false
						model.ActivationRules[0].RequireJustification = false
						model.ActivationRules[0].RequireTicketInfo = false

						if enabledRules := rule.EnabledRules; enabledRules != nil {
							for _, enabledRule := range *enabledRules {
								switch enabledRule {
								case "MultiFactorAuthentication":
									model.ActivationRules[0].RequireMultiFactorAuth = true
								case "Justification":
									model.ActivationRules[0].RequireJustification = true
								case "Ticketing":
									model.ActivationRules[0].RequireTicketInfo = true
								}
							}
						}

					case "Expiration_Admin_Eligibility":
						model.EligibleAssignmentRules[0].ExpirationRequired = pointer.From(rule.IsExpirationRequired)
						model.EligibleAssignmentRules[0].ExpireAfter = pointer.From(rule.MaximumDuration)

					case "Expiration_Admin_Assignment":
						model.ActiveAssignmentRules[0].ExpirationRequired = pointer.From(rule.IsExpirationRequired)
						model.ActiveAssignmentRules[0].ExpireAfter = pointer.From(rule.MaximumDuration)

					case "Expiration_EndUser_Assignment":
						model.ActivationRules[0].MaximumDuration = pointer.From(rule.MaximumDuration)

					case "Notification_Admin_Admin_Assignment":
						model.NotificationRules[0].ActiveAssignments[0].AdminNotifications = []GroupRoleManagementPolicyNotificationSettings{
							flattenNotificationSettings(rule),
						}

					case "Notification_Admin_Admin_Eligibility":
						model.NotificationRules[0].EligibleAssignments[0].AdminNotifications = []GroupRoleManagementPolicyNotificationSettings{
							flattenNotificationSettings(rule),
						}

					case "Notification_Admin_EndUser_Assignment":
						model.NotificationRules[0].EligibleActivations[0].AdminNotifications = []GroupRoleManagementPolicyNotificationSettings{
							flattenNotificationSettings(rule),
						}

					case "Notification_Approver_Admin_Assignment":
						model.NotificationRules[0].ActiveAssignments[0].ApproverNotifications = []GroupRoleManagementPolicyNotificationSettings{
							flattenNotificationSettings(rule),
						}

					case "Notification_Approver_Admin_Eligibility":
						model.NotificationRules[0].EligibleAssignments[0].ApproverNotifications = []GroupRoleManagementPolicyNotificationSettings{
							flattenNotificationSettings(rule),
						}

					case "Notification_Approver_EndUser_Assignment":
						model.NotificationRules[0].EligibleActivations[0].ApproverNotifications = []GroupRoleManagementPolicyNotificationSettings{
							flattenNotificationSettings(rule),
						}

					case "Notification_Requestor_Admin_Assignment":
						model.NotificationRules[0].ActiveAssignments[0].AssigneeNotifications = []GroupRoleManagementPolicyNotificationSettings{
							flattenNotificationSettings(rule),
						}

					case "Notification_Requestor_Admin_Eligibility":
						model.NotificationRules[0].EligibleAssignments[0].AssigneeNotifications = []GroupRoleManagementPolicyNotificationSettings{
							flattenNotificationSettings(rule),
						}

					case "Notification_Requestor_EndUser_Assignment":
						model.NotificationRules[0].EligibleActivations[0].AssigneeNotifications = []GroupRoleManagementPolicyNotificationSettings{
							flattenNotificationSettings(rule),
						}
					}
				}
			}

			return metadata.Encode(&model)
		},
	}
}
