package github.com/hashicorp/terraform-provider-azuread/internal/services/identitygovernance
import (
	"context"
	"fmt"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/common-types/stable"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/identitygovernance/stable/privilegedaccessgroupeligibilityschedule"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/identitygovernance/stable/privilegedaccessgroupeligibilityschedulerequest"
	"github.com/hashicorp/go-azure-sdk/sdk/nullable"
	"github.com/hashicorp/go-azure-sdk/sdk/odata"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azuread/internal/sdk"
	"github.com/hashicorp/terraform-provider-azuread/internal/services/identitygovernance/parse"
)
func (r PrivilegedAccessGroupEligibilityScheduleResource) Read() sdk.ResourceFunc {
	return sdk.ResourceFunc{
		Timeout: 5 * time.Minute,
		Func: func(ctx context.Context, metadata sdk.ResourceMetaData) error {
			scheduleClient := metadata.Client.IdentityGovernance.PrivilegedAccessGroupEligibilityScheduleClient
			requestsClient := metadata.Client.IdentityGovernance.PrivilegedAccessGroupEligibilityScheduleRequestClient

			resourceId, err := parse.ParsePrivilegedAccessGroupScheduleID(metadata.ResourceData.Id())
			if err != nil {
				return err
			}

			var model PrivilegedAccessGroupScheduleModel
			if err = metadata.Decode(&model); err != nil {
				return fmt.Errorf("decoding: %+v", err)
			}

			id := stable.NewIdentityGovernancePrivilegedAccessGroupEligibilityScheduleID(resourceId.ID())

			scheduleResp, err := scheduleClient.GetPrivilegedAccessGroupEligibilitySchedule(ctx, id, privilegedaccessgroupeligibilityschedule.DefaultGetPrivilegedAccessGroupEligibilityScheduleOperationOptions())
			if err != nil && !response.WasNotFound(scheduleResp.HttpResponse) {
				return fmt.Errorf("retrieving %s: %+v", id, err)
			}

			schedule := scheduleResp.Model

			// Some details are only available on the request which is used for the create/update of the schedule.
			// Schedule requests are never deleted. New ones are created when changes are made.
			// Therefore, on read, we need to find the latest version of the request.
			// This is to cater for changes being made outside of Terraform.
			options := privilegedaccessgroupeligibilityschedulerequest.ListPrivilegedAccessGroupEligibilityScheduleRequestsOperationOptions{
				Filter: pointer.To(fmt.Sprintf("groupId eq '%s' and targetScheduleId eq '%s'", resourceId.GroupId, resourceId.ID())),
				OrderBy: pointer.To(odata.OrderBy{
					Field:     "createdDateTime",
					Direction: odata.Descending,
				}),
			}
			requestsResp, err := requestsClient.ListPrivilegedAccessGroupEligibilityScheduleRequests(ctx, options)
			if err != nil {
				return fmt.Errorf("listing requests: %v", err)
			}

			var request *stable.PrivilegedAccessGroupEligibilityScheduleRequest

			requests := requestsResp.Model
			if requests == nil || len(*requests) == 0 {
				if response.WasNotFound(scheduleResp.HttpResponse) {
					// No request and no schedule was found
					return metadata.MarkAsGone(resourceId)
				}
			} else {
				request = pointer.To((*requests)[0])
			}

			var scheduleInfo *stable.RequestSchedule

			if request != nil {
				// The request is still present, populate from the request
				scheduleInfo = request.ScheduleInfo

				model.AssignmentType = string(request.AccessId)
				model.GroupId = request.GroupId.GetOrZero()
				model.Justification = request.Justification.GetOrZero()
				model.PrincipalId = request.PrincipalId.GetOrZero()
				model.Status = pointer.From(request.Status)

				if ticketInfo := request.TicketInfo; ticketInfo != nil {
					model.TicketNumber = ticketInfo.TicketNumber.GetOrZero()
					model.TicketSystem = ticketInfo.TicketSystem.GetOrZero()
				}
			} else if schedule != nil {
				// The request has likely expired, so populate from the schedule
				scheduleInfo = &schedule.ScheduleInfo

				model.AssignmentType = string(schedule.AccessId)
				model.GroupId = schedule.GroupId.GetOrZero()
				model.PrincipalId = schedule.PrincipalId.GetOrZero()
				model.Status = schedule.Status.GetOrZero()
			}

			if scheduleInfo != nil {
				model.StartDate = scheduleInfo.StartDateTime.GetOrZero()

				if expiration := scheduleInfo.Expiration; expiration != nil {
					model.Duration = expiration.Duration.GetOrZero()
					model.ExpirationDate = expiration.EndDateTime.GetOrZero()

					if expiration.Type != nil {
						model.PermanentAssignment = *expiration.Type == stable.ExpirationPatternType_NoExpiration
					}
				}
			}

			return metadata.Encode(&model)
		},
	}
}
