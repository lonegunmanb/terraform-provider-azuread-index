package github.com/hashicorp/terraform-provider-azuread/internal/services/identitygovernance
import (
	"context"
	"fmt"
	"strings"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/common-types/beta"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/identitygovernance/beta/entitlementmanagementaccesspackage"
	"github.com/hashicorp/go-azure-sdk/sdk/nullable"
	"github.com/hashicorp/go-azure-sdk/sdk/odata"
	"golang.org/x/text/cases"
	"golang.org/x/text/language"
)
func expandAccessPackageQuestions(input []interface{}) *[]beta.AccessPackageQuestion {
	result := make([]beta.AccessPackageQuestion, 0)

	for _, raw := range input {
		v := raw.(map[string]interface{})

		textList := v["text"].([]interface{})
		if len(textList) == 0 {
			continue
		}
		text := textList[0].(map[string]interface{})

		var question beta.AccessPackageQuestion

		if choicesRaw, ok := v["choice"].([]interface{}); ok && len(choicesRaw) > 0 {
			choices := make([]beta.AccessPackageAnswerChoice, 0)
			for _, choiceRaw := range choicesRaw {
				choice := choiceRaw.(map[string]interface{})
				displayValue := make(map[string]interface{})
				if v := choice["display_value"].([]interface{}); len(v) > 0 {
					displayValue = v[0].(map[string]interface{})
				}

				choices = append(choices, beta.AccessPackageAnswerChoice{
					ActualValue:  nullable.NoZero(choice["actual_value"].(string)),
					DisplayValue: pointer.From(expandAccessPackageLocalizedContent(displayValue)),
				})
			}

			question = beta.AccessPackageMultipleChoiceQuestion{
				Choices:    &choices,
				IsRequired: nullable.Value(v["required"].(bool)),
				Sequence:   nullable.Value(int64(v["sequence"].(int))),
				Text:       expandAccessPackageLocalizedContent(text),
			}
		} else {
			question = beta.AccessPackageTextInputQuestion{
				IsRequired: nullable.Value(v["required"].(bool)),
				Sequence:   nullable.Value(int64(v["sequence"].(int))),
				Text:       expandAccessPackageLocalizedContent(text),
			}
		}

		result = append(result, question)
	}

	return &result
}
