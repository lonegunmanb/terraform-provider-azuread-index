package github.com/hashicorp/terraform-provider-azuread/internal/services/directoryroles
import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/common-types/stable"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/rolemanagement/stable/directoryroleeligibilityschedule"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/rolemanagement/stable/directoryroleeligibilityschedulerequest"
	"github.com/hashicorp/go-azure-sdk/sdk/nullable"
	"github.com/hashicorp/go-azure-sdk/sdk/odata"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-provider-azuread/internal/clients"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/consistency"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf/validation"
)
func directoryRoleEligibilityScheduleRequestResourceRead(ctx context.Context, d *pluginsdk.ResourceData, meta interface{}) pluginsdk.Diagnostics {
	client := meta.(*clients.Client).DirectoryRoles.DirectoryRoleEligibilityScheduleRequestClient
	scheduleClient := meta.(*clients.Client).DirectoryRoles.DirectoryRoleEligibilityScheduleClient
	id := stable.NewRoleManagementDirectoryRoleEligibilityScheduleRequestID(d.Id())

	resp, err := client.GetDirectoryRoleEligibilityScheduleRequest(ctx, id, directoryroleeligibilityschedulerequest.DefaultGetDirectoryRoleEligibilityScheduleRequestOperationOptions())
	if err != nil {
		// Check if the Schedule still exists, any other error we must return
		if !response.WasNotFound(resp.HttpResponse) {
			return tf.ErrorDiagF(err, "Retrieving %s", id)
		}

		// After (typically) 45 days the request resources are purged by the service, however, the underlying resource (the schedule) has the same GUID, so we need to check if it's still there or Terraform will try to recreate this resource and fail as it already exists.
		// TODO - This resource needs a redesign/replacement in the longer term to avoid this, however, this will likely be a breaking change requiring a major version to implement.
		scheduleID := stable.NewRoleManagementDirectoryRoleEligibilityScheduleID(d.Id())
		scheduleResp, err2 := scheduleClient.GetDirectoryRoleEligibilitySchedule(ctx, scheduleID, directoryroleeligibilityschedule.DefaultGetDirectoryRoleEligibilityScheduleOperationOptions())
		if err2 != nil {
			if response.WasNotFound(scheduleResp.HttpResponse) {
				log.Printf("[DEBUG] %s was not found - removing from state", id)
				d.SetId("")
				return nil
			}
		}
		roleEligibilitySchedule := scheduleResp.Model
		if roleEligibilitySchedule == nil {
			return tf.ErrorDiagF(errors.New("model was nil"), "API Error")
		}

		tf.Set(d, "role_definition_id", roleEligibilitySchedule.RoleDefinitionId.GetOrZero())
		tf.Set(d, "principal_id", roleEligibilitySchedule.PrincipalId.GetOrZero())
		// Schedules do not expose the `justification` field, so we best effort it here and try and get it from config as it's a required property
		tf.Set(d, "justification", d.Get("justification").(string))
		tf.Set(d, "directory_scope_id", roleEligibilitySchedule.DirectoryScopeId.GetOrZero())

		return nil
	}

	roleEligibilityScheduleRequest := resp.Model
	if roleEligibilityScheduleRequest == nil {
		return tf.ErrorDiagF(errors.New("model was nil"), "API Error")
	}

	tf.Set(d, "role_definition_id", roleEligibilityScheduleRequest.RoleDefinitionId.GetOrZero())
	tf.Set(d, "principal_id", roleEligibilityScheduleRequest.PrincipalId.GetOrZero())
	tf.Set(d, "justification", roleEligibilityScheduleRequest.Justification.GetOrZero())
	tf.Set(d, "directory_scope_id", roleEligibilityScheduleRequest.DirectoryScopeId.GetOrZero())

	return nil
}
