package github.com/hashicorp/terraform-provider-azuread/internal/services/serviceprincipals
import (
	"context"
	"crypto/sha1"
	"encoding/base64"
	"errors"
	"fmt"
	"net/http"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-sdk/sdk/odata"
	"github.com/hashicorp/terraform-provider-azuread/internal/clients"
	"github.com/hashicorp/terraform-provider-azuread/internal/tf"
	"github.com/hashicorp/terraform-provider-azuread/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azuread/internal/tf/validation"
	"github.com/manicminer/hamilton/msgraph"
)
func servicePrincipalsDataSourceRead(ctx context.Context, d *pluginsdk.ResourceData, meta interface{}) pluginsdk.Diagnostics {
	client := meta.(*clients.Client).ServicePrincipals.ServicePrincipalsClient
	client.BaseClient.DisableRetries = true
	defer func() { client.BaseClient.DisableRetries = false }()

	var servicePrincipals []msgraph.ServicePrincipal
	var expectedCount int
	ignoreMissing := d.Get("ignore_missing").(bool)
	returnAll := d.Get("return_all").(bool)

	var clientIdsToSearch []string
	if v, ok := d.Get("client_ids").([]interface{}); ok && len(v) > 0 {
		clientIdsToSearch = tf.ExpandStringSlice(v)
	} else if v, ok := d.Get("application_ids").([]interface{}); ok && len(v) > 0 {
		clientIdsToSearch = tf.ExpandStringSlice(v)
	}
	if returnAll {
		result, _, err := client.List(ctx, odata.Query{})
		if err != nil {
			return tf.ErrorDiagF(err, "Could not retrieve service principals")
		}
		if result == nil {
			return tf.ErrorDiagF(errors.New("API returned nil result"), "Bad API Response")
		}
		if len(*result) == 0 {
			return tf.ErrorDiagPathF(err, "return_all", "No service principals found")
		}

		servicePrincipals = append(servicePrincipals, *result...)
	} else if len(clientIdsToSearch) > 0 {
		expectedCount = len(clientIdsToSearch)
		for _, v := range clientIdsToSearch {
			query := odata.Query{
				Filter: fmt.Sprintf("appId eq '%s'", v),
			}
			result, _, err := client.List(ctx, query)
			if err != nil {
				return tf.ErrorDiagF(err, "Finding service principal with application ID: %q", v)
			}
			if result == nil {
				return tf.ErrorDiagF(errors.New("API returned nil result"), "Bad API Response")
			}

			count := len(*result)
			if count > 1 {
				return tf.ErrorDiagPathF(nil, "mail_nicknames", "More than one service principal found with application ID: %q", v)
			} else if count == 0 {
				if ignoreMissing {
					continue
				}
				return tf.ErrorDiagPathF(err, "mail_nicknames", "Service principal not found with application ID: %q", v)
			}

			servicePrincipals = append(servicePrincipals, (*result)[0])
		}
	} else if displayNames, ok := d.Get("display_names").([]interface{}); ok && len(displayNames) > 0 {
		expectedCount = len(displayNames)
		for _, v := range displayNames {
			query := odata.Query{
				Filter: fmt.Sprintf("displayName eq '%s'", v),
			}
			result, _, err := client.List(ctx, query)
			if err != nil {
				return tf.ErrorDiagF(err, "Finding service principal; with display name: %q", v)
			}
			if result == nil {
				return tf.ErrorDiagF(errors.New("API returned nil result"), "Bad API Response")
			}
			count := len(*result)
			if count > 1 {
				return tf.ErrorDiagPathF(nil, "display_names", "More than one service principal found with display name: %q", v)
			} else if count == 0 {
				if ignoreMissing {
					continue
				}
				return tf.ErrorDiagPathF(err, "display_names", "Service principal with display name %q was not found", v)
			}

			servicePrincipals = append(servicePrincipals, (*result)[0])
		}
	} else if objectIds, ok := d.Get("object_ids").([]interface{}); ok && len(objectIds) > 0 {
		expectedCount = len(objectIds)
		for _, v := range objectIds {
			u, status, err := client.Get(ctx, v.(string), odata.Query{})
			if err != nil {
				if status == http.StatusNotFound {
					if ignoreMissing {
						continue
					}
					return tf.ErrorDiagPathF(nil, "object_id", "Service principal not found with object ID: %q", v)
				}
				return tf.ErrorDiagF(err, "Retrieving service principal with object ID: %q", v)
			}
			if u == nil {
				return tf.ErrorDiagPathF(nil, "object_id", "Service principal not found with object ID: %q", v)
			}

			servicePrincipals = append(servicePrincipals, *u)
		}
	}

	// Check that the right number of service principals were returned
	if !returnAll && !ignoreMissing && len(servicePrincipals) != expectedCount {
		return tf.ErrorDiagF(fmt.Errorf("Expected: %d, Actual: %d", expectedCount, len(servicePrincipals)), "Unexpected number of service principals returned")
	}

	clientIds := make([]string, 0)
	displayNames := make([]string, 0)
	objectIds := make([]string, 0)
	spList := make([]map[string]interface{}, 0)
	for _, s := range servicePrincipals {
		if s.ID() == nil || s.DisplayName == nil {
			return tf.ErrorDiagF(errors.New("API returned service principal with nil object ID or displayName"), "Bad API Response")
		}

		objectIds = append(objectIds, *s.ID())
		displayNames = append(displayNames, *s.DisplayName)
		if s.AppId != nil {
			clientIds = append(clientIds, *s.AppId)
		}

		servicePrincipalNames := make([]string, 0)
		if s.ServicePrincipalNames != nil {
			for _, name := range *s.ServicePrincipalNames {
				// Exclude the app ID from the list of service principal names
				if s.AppId == nil || !strings.EqualFold(name, *s.AppId) {
					servicePrincipalNames = append(servicePrincipalNames, name)
				}
			}
		}

		sp := make(map[string]interface{})
		sp["account_enabled"] = s.AccountEnabled
		sp["display_name"] = s.DisplayName
		sp["app_role_assignment_required"] = s.AppRoleAssignmentRequired
		sp["application_id"] = s.AppId
		sp["application_tenant_id"] = s.AppOwnerOrganizationId
		sp["client_id"] = s.AppId
		sp["object_id"] = s.ID()
		sp["preferred_single_sign_on_mode"] = s.PreferredSingleSignOnMode
		sp["saml_metadata_url"] = s.SamlMetadataUrl
		sp["service_principal_names"] = servicePrincipalNames
		sp["sign_in_audience"] = s.SignInAudience
		sp["tags"] = s.Tags
		sp["type"] = s.ServicePrincipalType
		spList = append(spList, sp)
	}

	// Generate a unique ID based on result
	h := sha1.New()
	if _, err := h.Write([]byte(strings.Join(objectIds, "/"))); err != nil {
		return tf.ErrorDiagF(err, "Unable to compute hash for object IDs")
	}

	d.SetId("serviceprincipals#" + base64.URLEncoding.EncodeToString(h.Sum(nil)))
	tf.Set(d, "application_ids", clientIds)
	tf.Set(d, "client_ids", clientIds)
	tf.Set(d, "display_names", displayNames)
	tf.Set(d, "object_ids", objectIds)
	tf.Set(d, "service_principals", spList)

	return nil
}
