package github.com/hashicorp/terraform-provider-azuread/internal/services/serviceprincipals
import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/common-types/beta"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/common-types/stable"
	serviceprincipalBeta "github.com/hashicorp/go-azure-sdk/microsoft-graph/serviceprincipals/beta/serviceprincipal"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/serviceprincipals/stable/owner"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/serviceprincipals/stable/serviceprincipal"
	"github.com/hashicorp/go-azure-sdk/sdk/nullable"
	"github.com/hashicorp/go-azure-sdk/sdk/odata"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-provider-azuread/internal/clients"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/applications"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/consistency"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf/validation"
	"github.com/hashicorp/terraform-provider-azuread/internal/services/serviceprincipals/migrations"
)
func servicePrincipalResourceCreate(ctx context.Context, d *pluginsdk.ResourceData, meta interface{}) pluginsdk.Diagnostics {
	client := meta.(*clients.Client).ServicePrincipals.ServicePrincipalClient
	ownerClient := meta.(*clients.Client).ServicePrincipals.ServicePrincipalOwnerClient

	callerId := meta.(*clients.Client).ObjectID
	clientId := d.Get("client_id").(string)

	listOptions := serviceprincipal.ListServicePrincipalsOperationOptions{
		Filter: pointer.To(fmt.Sprintf("appId eq '%s'", odata.EscapeSingleQuote(clientId))),
	}
	listResp, err := client.ListServicePrincipals(ctx, listOptions)
	if err != nil {
		return tf.ErrorDiagF(err, "Could not list existing service principals")
	}

	if listResp.Model == nil {
		return tf.ErrorDiagF(errors.New("model was nil"), "Could not list existing service principals")
	}
	if len(*listResp.Model) > 1 {
		return tf.ErrorDiagF(fmt.Errorf("unexpected number of service principals returned (expected: 1, received: %d", len(*listResp.Model)), "Could not list existing service principals")
	}

	if len(*listResp.Model) == 1 {
		servicePrincipal := (*listResp.Model)[0]

		if servicePrincipal.Id == nil || *servicePrincipal.Id == "" {
			return tf.ErrorDiagF(fmt.Errorf("service principal returned with nil or empty object ID"), "API error")
		}

		if d.Get("use_existing").(bool) {
			id := stable.NewServicePrincipalID(*servicePrincipal.Id)
			d.SetId(id.ID())
			return servicePrincipalResourceUpdate(ctx, d, meta)
		}

		return tf.ImportAsExistsDiag("azuread_service_principal", *servicePrincipal.Id)
	}

	var tags []string
	if v, ok := d.GetOk("feature_tags"); ok {
		tags = applications.ExpandFeatures(v.([]interface{}))
	} else if v, ok := d.GetOk("features"); ok {
		tags = applications.ExpandFeatures(v.([]interface{}))
	} else {
		tags = tf.ExpandStringSlice(d.Get("tags").(*pluginsdk.Set).List())
	}

	// Set a temporary description as we'll attempt to patch the service principal with the correct description after creating it
	uid, err := uuid.GenerateUUID()
	if err != nil {
		return tf.ErrorDiagF(err, "Failed to generate a UUID")
	}
	tempDescription := fmt.Sprintf("TERRAFORM_UPDATE_%s", uid)

	properties := stable.ServicePrincipal{
		AccountEnabled:             nullable.Value(d.Get("account_enabled").(bool)),
		AlternativeNames:           tf.ExpandStringSlicePtr(d.Get("alternative_names").(*pluginsdk.Set).List()),
		AppId:                      nullable.Value(clientId),
		AppRoleAssignmentRequired:  pointer.To(d.Get("app_role_assignment_required").(bool)),
		Description:                nullable.NoZero(tempDescription),
		LoginUrl:                   nullable.NoZero(d.Get("login_url").(string)),
		Notes:                      nullable.NoZero(d.Get("notes").(string)),
		NotificationEmailAddresses: tf.ExpandStringSlicePtr(d.Get("notification_email_addresses").(*pluginsdk.Set).List()),
		PreferredSingleSignOnMode:  nullable.NoZero(d.Get("preferred_single_sign_on_mode").(string)),
		SamlSingleSignOnSettings:   expandSamlSingleSignOn(d.Get("saml_single_sign_on").([]interface{})),
		Tags:                       &tags,
	}

	// Sort the owners into two slices, the first containing up to 20 and the rest overflowing to the second slice
	// The calling principal should always be in the first slice of owners
	ownersFirst20 := []string{fmt.Sprintf("%s%s", client.Client.BaseUri, stable.NewDirectoryObjectID(callerId).ID())}
	var ownersExtra []stable.ReferenceCreate

	// Track whether we need to remove the calling principal later on
	removeCallerOwner := true

	// Retrieve and set the initial owners, which can be up to 20 in total when creating the application
	if v, ok := d.GetOk("owners"); ok {
		ownerCount := 0
		for _, ownerIdRaw := range v.(*pluginsdk.Set).List() {
			ownerId := ownerIdRaw.(string)

			// If the calling principal was found in the specified owners, we won't remove them later
			if strings.EqualFold(ownerId, callerId) {
				removeCallerOwner = false
				continue
			}

			if ownerCount < 19 {
				ownersFirst20 = append(ownersFirst20, client.Client.BaseUri+stable.NewDirectoryObjectID(ownerId).ID())
			} else {
				ownerObject := stable.ReferenceCreate{
					ODataId: pointer.To(client.Client.BaseUri + stable.NewDirectoryObjectID(ownerId).ID()),
				}
				ownersExtra = append(ownersExtra, ownerObject)
			}
			ownerCount++
		}
	}

	// Set the initial owners, which should include the calling principal plus up to 19 of owners specified in configuration
	properties.Owners_ODataBind = &ownersFirst20

	options := serviceprincipal.CreateServicePrincipalOperationOptions{
		RetryFunc: func(resp *http.Response, o *odata.OData) (bool, error) {
			if o != nil && o.Error != nil {
				if response.WasBadRequest(resp) {
					return o.Error.Match("The appId '.+' of the service principal does not reference a valid application object"), nil
				} else if response.WasForbidden(resp) {
					// This error is misleading and is usually due to the application object not being fully replicated
					return o.Error.Match("When using this permission, the backing application of the service principal being created must in the local tenant"), nil
				}
			}
			return false, nil
		},
	}

	resp, err := client.CreateServicePrincipal(ctx, properties, options)
	if err != nil {
		return tf.ErrorDiagF(err, "Could not create service principal")
	}

	servicePrincipal := resp.Model
	if servicePrincipal == nil {
		return tf.ErrorDiagF(errors.New("model was nil"), "Could not create service principal")
	}

	if servicePrincipal.Id == nil || *servicePrincipal.Id == "" {
		return tf.ErrorDiagF(errors.New("Object ID returned for service principal is nil"), "Bad API response")
	}

	id := stable.NewServicePrincipalID(*servicePrincipal.Id)
	d.SetId(id.ID())

	// Attempt to patch the newly created service principal with the correct description, which will tell us whether it exists yet
	// The SDK handles retries for us here in the event of 404, 429 or 5xx, then returns after giving up
	if resp, err := client.UpdateServicePrincipal(ctx, id, stable.ServicePrincipal{
		Description: nullable.NoZero(d.Get("description").(string)),
	}, serviceprincipal.DefaultUpdateServicePrincipalOperationOptions()); err != nil {
		if response.WasNotFound(resp.HttpResponse) {
			return tf.ErrorDiagF(err, "Timed out whilst waiting for new service principal to be replicated in Azure AD")
		}
		return tf.ErrorDiagF(err, "Failed to patch service principal after creating")
	}

	// Add any remaining owners after the service principal is created
	for _, ref := range ownersExtra {
		if _, err = ownerClient.AddOwnerRef(ctx, id, ref, owner.DefaultAddOwnerRefOperationOptions()); err != nil {
			return tf.ErrorDiagF(err, "Could not add owners to %s", id)
		}
	}

	// If the calling principal was not included in configuration, remove it now
	if removeCallerOwner {
		ownerId := stable.NewServicePrincipalIdOwnerID(id.ServicePrincipalId, callerId)
		if _, err = ownerClient.RemoveOwnerRef(ctx, ownerId, owner.DefaultRemoveOwnerRefOperationOptions()); err != nil {
			return tf.ErrorDiagF(err, "Could not remove initial owner from %s", id)
		}
	}

	return servicePrincipalResourceRead(ctx, d, meta)
}
