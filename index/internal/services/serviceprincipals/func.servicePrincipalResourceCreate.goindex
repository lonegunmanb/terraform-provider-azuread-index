package github.com/hashicorp/terraform-provider-azuread/internal/services/serviceprincipals
import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-sdk/sdk/odata"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-provider-azuread/internal/clients"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers"
	"github.com/hashicorp/terraform-provider-azuread/internal/tf"
	"github.com/hashicorp/terraform-provider-azuread/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azuread/internal/tf/validation"
	"github.com/manicminer/hamilton/msgraph"
)
func servicePrincipalResourceCreate(ctx context.Context, d *pluginsdk.ResourceData, meta interface{}) pluginsdk.Diagnostics {
	client := meta.(*clients.Client).ServicePrincipals.ServicePrincipalsClient
	directoryObjectsClient := meta.(*clients.Client).ServicePrincipals.DirectoryObjectsClient
	callerId := meta.(*clients.Client).ObjectID
	tenantId := meta.(*clients.Client).TenantID

	var clientId string
	if v := d.Get("client_id").(string); v != "" {
		clientId = v
	} else {
		clientId = d.Get("application_id").(string)
	}

	var servicePrincipal *msgraph.ServicePrincipal
	var err error

	if d.Get("use_existing").(bool) {
		// Assume that a service principal already exists and try to look for it, whilst retrying to defeat eventual consistency
		servicePrincipal, err = findByClientIdWithTimeout(ctx, 5*time.Minute, client, clientId)
	} else {
		// Otherwise perform a single List operation to check for an existing service principal
		servicePrincipal, err = findByClientId(ctx, client, clientId)
	}
	if err != nil {
		return tf.ErrorDiagF(err, "Could not list existing service principals")
	}

	if servicePrincipal != nil {
		if servicePrincipal.ID() == nil || *servicePrincipal.ID() == "" {
			return tf.ErrorDiagF(fmt.Errorf("service principal returned with nil or empty object ID"), "API error")
		}
		if !d.Get("use_existing").(bool) {
			return tf.ImportAsExistsDiag("azuread_service_principal", *servicePrincipal.ID())
		}

		d.SetId(*servicePrincipal.ID())
		return servicePrincipalResourceUpdate(ctx, d, meta)
	}

	var tags []string
	if v, ok := d.GetOk("feature_tags"); ok {
		tags = helpers.ApplicationExpandFeatures(v.([]interface{}))
	} else if v, ok := d.GetOk("features"); ok {
		tags = helpers.ApplicationExpandFeatures(v.([]interface{}))
	} else {
		tags = tf.ExpandStringSlice(d.Get("tags").(*pluginsdk.Set).List())
	}

	// Set a temporary description as we'll attempt to patch the service principal with the correct description after creating it
	uuid, err := uuid.GenerateUUID()
	if err != nil {
		return tf.ErrorDiagF(err, "Failed to generate a UUID")
	}
	tempDescription := fmt.Sprintf("TERRAFORM_UPDATE_%s", uuid)

	properties := msgraph.ServicePrincipal{
		AccountEnabled:             pointer.To(d.Get("account_enabled").(bool)),
		AlternativeNames:           tf.ExpandStringSlicePtr(d.Get("alternative_names").(*pluginsdk.Set).List()),
		AppId:                      pointer.To(clientId),
		AppRoleAssignmentRequired:  pointer.To(d.Get("app_role_assignment_required").(bool)),
		Description:                tf.NullableString(tempDescription),
		LoginUrl:                   tf.NullableString(d.Get("login_url").(string)),
		Notes:                      tf.NullableString(d.Get("notes").(string)),
		NotificationEmailAddresses: tf.ExpandStringSlicePtr(d.Get("notification_email_addresses").(*pluginsdk.Set).List()),
		PreferredSingleSignOnMode:  tf.NullableString(d.Get("preferred_single_sign_on_mode").(string)),
		SamlSingleSignOnSettings:   expandSamlSingleSignOn(d.Get("saml_single_sign_on").([]interface{})),
		Tags:                       &tags,
	}

	// Sort the owners into two slices, the first containing up to 20 and the rest overflowing to the second slice
	// The calling principal should always be in the first slice of owners
	callerObject, _, err := directoryObjectsClient.Get(ctx, callerId, odata.Query{})
	if err != nil {
		return tf.ErrorDiagF(err, "Could not retrieve calling principal object %q", callerId)
	}
	if callerObject == nil {
		return tf.ErrorDiagF(errors.New("returned callerObject was nil"), "Could not retrieve calling principal object %q", callerId)
	}

	// @odata.id returned by API cannot be relied upon, so construct our own
	callerObject.ODataId = (*odata.Id)(pointer.To(fmt.Sprintf("%s/v1.0/%s/directoryObjects/%s",
		client.BaseClient.Endpoint, tenantId, callerId)))

	ownersFirst20 := msgraph.Owners{*callerObject}
	var ownersExtra msgraph.Owners

	// Track whether we need to remove the calling principal later on
	removeCallerOwner := true

	// Retrieve and set the initial owners, which can be up to 20 in total when creating the service principal
	if v, ok := d.GetOk("owners"); ok {
		ownerCount := 0
		for _, ownerIdRaw := range v.(*pluginsdk.Set).List() {
			ownerId := ownerIdRaw.(string)

			// If the calling principal was found in the specified owners, we won't remove them later
			if strings.EqualFold(ownerId, callerId) {
				removeCallerOwner = false
				continue
			}

			ownerObject := msgraph.DirectoryObject{
				ODataId: (*odata.Id)(pointer.To(fmt.Sprintf("%s/v1.0/%s/directoryObjects/%s",
					client.BaseClient.Endpoint, tenantId, ownerId))),
				Id: &ownerId,
			}

			if ownerCount < 19 {
				ownersFirst20 = append(ownersFirst20, ownerObject)
			} else {
				ownersExtra = append(ownersExtra, ownerObject)
			}
			ownerCount++
		}
	}

	// Set the initial owners, which should include the calling principal plus up to 19 of owners specified in configuration
	properties.Owners = &ownersFirst20

	servicePrincipal, _, err = client.Create(ctx, properties)
	if err != nil {
		return tf.ErrorDiagF(err, "Could not create service principal")
	}

	if servicePrincipal.ID() == nil || *servicePrincipal.ID() == "" {
		return tf.ErrorDiagF(errors.New("Object ID returned for service principal is nil"), "Bad API response")
	}
	d.SetId(*servicePrincipal.ID())

	// Attempt to patch the newly created service principal with the correct description, which will tell us whether it exists yet
	// The SDK handles retries for us here in the event of 404, 429 or 5xx, then returns after giving up
	status, err := client.Update(ctx, msgraph.ServicePrincipal{
		DirectoryObject: msgraph.DirectoryObject{
			Id: servicePrincipal.ID(),
		},
		Description: tf.NullableString(d.Get("description").(string)),
	})
	if err != nil {
		if status == http.StatusNotFound {
			return tf.ErrorDiagF(err, "Timed out whilst waiting for new service principal to be replicated in Azure AD")
		}
		return tf.ErrorDiagF(err, "Failed to patch service principal after creating")
	}

	// Add any remaining owners after the service principal is created
	if len(ownersExtra) > 0 {
		servicePrincipal.Owners = &ownersExtra
		if _, err := client.AddOwners(ctx, servicePrincipal); err != nil {
			return tf.ErrorDiagF(err, "Could not add owners to service principal with object ID: %q", d.Id())
		}
	}

	// If the calling principal was not included in configuration, remove it now
	if removeCallerOwner {
		if _, err = client.RemoveOwners(ctx, d.Id(), &[]string{callerId}); err != nil {
			return tf.ErrorDiagF(err, "Could not remove initial owner from service principal with object ID: %q", d.Id())
		}
	}

	return servicePrincipalResourceRead(ctx, d, meta)
}
