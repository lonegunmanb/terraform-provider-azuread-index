package github.com/hashicorp/terraform-provider-azuread/internal/services/applications
import (
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/applications/stable/application"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/common-types/stable"
	"github.com/hashicorp/go-azure-sdk/sdk/client"
	"github.com/hashicorp/go-azure-sdk/sdk/nullable"
	"github.com/hashicorp/go-azure-sdk/sdk/odata"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/applications"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/credentials"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf/pluginsdk"
)
func applicationDisableAppRoles(ctx context.Context, client *application.ApplicationClient, applicationId stable.ApplicationId, newRoles *[]stable.AppRole) error {
	if newRoles == nil {
		newRoles = &[]stable.AppRole{}
	}

	resp, err := client.GetApplication(ctx, applicationId, application.DefaultGetApplicationOperationOptions())
	if err != nil {
		if response.WasNotFound(resp.HttpResponse) {
			return fmt.Errorf("%s was not found", applicationId)
		}

		return fmt.Errorf("retrieving %s: %v", applicationId, err)
	}

	app := resp.Model
	if app == nil {
		return fmt.Errorf("retrieving %s: model was nil", applicationId)
	}

	var existingRoles []stable.AppRole
	if app.AppRoles != nil {
		existingRoles = *app.AppRoles
	}

	// Shortcut: don't update if no changes to be made
	if reflect.DeepEqual(existingRoles, *newRoles) {
		return nil
	}

	// Identify any roles to be changed
	var disable bool
	for _, newRole := range *newRoles {
		if newRole.Id == nil || *newRole.Id == "" {
			return fmt.Errorf("new role provided with nil or empty ID")
		}
		for i, existing := range existingRoles {
			if existing.Id != nil && *existing.Id == *newRole.Id {
				if existing.IsEnabled != nil && *existing.IsEnabled && applicationAppRoleChanged(existing, newRole) {
					*existingRoles[i].IsEnabled = false
					disable = true
				}
				break
			}
		}
	}

	// Identify any roles to be removed
	for i, existing := range existingRoles {
		found := false
		for _, newRole := range *newRoles {
			if existing.Id != nil && *newRole.Id == *existing.Id {
				found = true
				break
			}
		}
		if !found {
			*existingRoles[i].IsEnabled = false
			disable = true
		}
	}

	if disable {
		// Disable any changed or removed roles
		properties := stable.Application{
			Id:       app.Id,
			AppRoles: &existingRoles,
		}
		if _, err = client.UpdateApplication(ctx, applicationId, properties, application.DefaultUpdateApplicationOperationOptions()); err != nil {
			return fmt.Errorf("disabling App Roles for %s: %v", applicationId, err)
		}

		// Wait for application manifest to reflect the disabled roles
		deadline, ok := ctx.Deadline()
		if !ok {
			return fmt.Errorf("context has no deadline")
		}
		timeout := time.Until(deadline)
		_, err = (&pluginsdk.StateChangeConf{ //nolint:staticcheck
			Pending:    []string{"Waiting"},
			Target:     []string{"Disabled"},
			Timeout:    timeout,
			MinTimeout: 1 * time.Second,
			Refresh: func() (interface{}, string, error) {
				resp, err := client.GetApplication(ctx, applicationId, application.DefaultGetApplicationOperationOptions())
				if err != nil {
					return nil, "Error", fmt.Errorf("retrieving %s: %v", applicationId, err)
				}
				app := resp.Model
				if app == nil || app.AppRoles == nil {
					return nil, "Error", fmt.Errorf("reading roles for %s: %v", applicationId, err)
				}
				actualRoles := *app.AppRoles
				for _, expectedRole := range existingRoles {
					if expectedRole.IsEnabled != nil && !*expectedRole.IsEnabled {
						for _, actualRole := range actualRoles {
							if expectedRole.Id != nil && actualRole.Id != nil && *expectedRole.Id == *actualRole.Id {
								if actualRole.IsEnabled != nil && *actualRole.IsEnabled {
									return actualRoles, "Waiting", nil
								}
								break
							}
						}
					}
				}
				return actualRoles, "Disabled", nil
			},
		}).WaitForStateContext(ctx)
		if err != nil {
			return fmt.Errorf("waiting for App Roles to be disabled for %s: %v", applicationId, err)
		}
	}

	return nil
}
