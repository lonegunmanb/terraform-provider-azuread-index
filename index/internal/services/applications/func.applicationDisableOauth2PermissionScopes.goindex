package github.com/hashicorp/terraform-provider-azuread/internal/services/applications
import (
	"context"
	"encoding/base64"
	"fmt"
	"net/http"
	"reflect"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/applications/stable/application"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/common-types/stable"
	"github.com/hashicorp/go-azure-sdk/sdk/client"
	"github.com/hashicorp/go-azure-sdk/sdk/nullable"
	"github.com/hashicorp/go-azure-sdk/sdk/odata"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/applications"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/credentials"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf/pluginsdk"
)
func applicationDisableOauth2PermissionScopes(ctx context.Context, client *application.ApplicationClient, applicationId stable.ApplicationId, newScopes *[]stable.PermissionScope) error {
	if newScopes == nil {
		newScopes = &[]stable.PermissionScope{}
	}

	resp, err := client.GetApplication(ctx, applicationId, application.DefaultGetApplicationOperationOptions())
	if err != nil {
		if response.WasNotFound(resp.HttpResponse) {
			return fmt.Errorf("%s was not found", applicationId)
		}

		return fmt.Errorf("retrieving %s: %v", applicationId, err)
	}

	app := resp.Model
	if app == nil {
		return fmt.Errorf("retrieving %s: model was nil", applicationId)
	}

	var existingScopes []stable.PermissionScope
	if app.Api != nil && app.Api.OAuth2PermissionScopes != nil {
		existingScopes = *app.Api.OAuth2PermissionScopes
	}

	// Don't update if no changes to be made
	if reflect.DeepEqual(existingScopes, *newScopes) {
		return nil
	}

	// Identify any scopes to be changed
	var disable bool
	for _, newScope := range *newScopes {
		if newScope.Id == nil || *newScope.Id == "" {
			return fmt.Errorf("new scope provided with nil or empty ID")
		}
		for i, existing := range existingScopes {
			if existing.Id != nil && *existing.Id == *newScope.Id {
				if existing.IsEnabled != nil && *existing.IsEnabled && !reflect.DeepEqual(existing, newScope) {
					*existingScopes[i].IsEnabled = false
					disable = true
				}
				break
			}
		}
	}

	// Identify any scopes to be removed
	for i, existing := range existingScopes {
		found := false
		for _, newScope := range *newScopes {
			if existing.Id != nil && *newScope.Id == *existing.Id {
				found = true
				break
			}
		}
		if !found {
			*existingScopes[i].IsEnabled = false
			disable = true
		}
	}

	if disable {
		// Disable any changed or removed scopes
		properties := stable.Application{
			Api: &stable.ApiApplication{
				OAuth2PermissionScopes: &existingScopes,
			},
		}
		if _, err = client.UpdateApplication(ctx, applicationId, properties, application.DefaultUpdateApplicationOperationOptions()); err != nil {
			return fmt.Errorf("disabling OAuth2 Permission Scopes for %s: %+v", applicationId, err)
		}

		// Wait for application manifest to reflect the disabled scopes
		deadline, ok := ctx.Deadline()
		if !ok {
			return fmt.Errorf("context has no deadline")
		}
		timeout := time.Until(deadline)
		_, err = (&pluginsdk.StateChangeConf{ //nolint:staticcheck
			Pending:    []string{"Waiting"},
			Target:     []string{"Disabled"},
			Timeout:    timeout,
			MinTimeout: 1 * time.Second,
			Refresh: func() (interface{}, string, error) {
				resp, err := client.GetApplication(ctx, applicationId, application.DefaultGetApplicationOperationOptions())
				if err != nil {
					return nil, "Error", fmt.Errorf("retrieving %s: %+v", applicationId, err)
				}
				app := resp.Model
				if app == nil || app.Api == nil || app.Api.OAuth2PermissionScopes == nil {
					return nil, "Error", fmt.Errorf("reading scopes for %s: %+v", applicationId, err)
				}
				actualScopes := *app.Api.OAuth2PermissionScopes
				for _, expectedScope := range existingScopes {
					if expectedScope.IsEnabled != nil && !*expectedScope.IsEnabled {
						for _, actualScope := range actualScopes {
							if expectedScope.Id != nil && actualScope.Id != nil && *expectedScope.Id == *actualScope.Id {
								if actualScope.IsEnabled != nil && *actualScope.IsEnabled {
									return actualScopes, "Waiting", nil
								}
								break
							}
						}
					}
				}
				return actualScopes, "Disabled", nil
			},
		}).WaitForStateContext(ctx)
		if err != nil {
			return fmt.Errorf("waiting for OAuth2 Permission Scopes to be disabled for %s: %+v", applicationId, err)
		}
	}

	return nil
}
