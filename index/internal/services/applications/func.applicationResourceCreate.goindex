package github.com/hashicorp/terraform-provider-azuread/internal/services/applications
import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/url"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	applicationBeta "github.com/hashicorp/go-azure-sdk/microsoft-graph/applications/beta/application"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/applications/stable/application"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/applications/stable/logo"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/applications/stable/owner"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/applicationtemplates/stable/applicationtemplate"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/common-types/beta"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/common-types/stable"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/serviceprincipals/stable/serviceprincipal"
	"github.com/hashicorp/go-azure-sdk/sdk/nullable"
	"github.com/hashicorp/go-azure-sdk/sdk/odata"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-provider-azuread/internal/clients"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/applications"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/consistency"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/credentials"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf/validation"
	"github.com/hashicorp/terraform-provider-azuread/internal/services/applications/migrations"
	applicationsValidate "github.com/hashicorp/terraform-provider-azuread/internal/services/applications/validate"
)
func applicationResourceCreate(ctx context.Context, d *pluginsdk.ResourceData, meta interface{}) pluginsdk.Diagnostics {
	client := meta.(*clients.Client).Applications.ApplicationClient
	clientBeta := meta.(*clients.Client).Applications.ApplicationClientBeta
	appTemplateClient := meta.(*clients.Client).Applications.ApplicationTemplateClient
	logoClient := meta.(*clients.Client).Applications.ApplicationLogoClient
	ownerClient := meta.(*clients.Client).Applications.ApplicationOwnerClient
	servicePrincipalsClient := meta.(*clients.Client).Applications.ServicePrincipalClient

	displayName := d.Get("display_name").(string)

	// Perform this check at apply time to catch any duplicate names created during the same apply
	if d.Get("prevent_duplicate_names").(bool) {
		result, err := applicationFindByName(ctx, client, displayName)
		if err != nil {
			return tf.ErrorDiagPathF(err, "name", "Could not check for existing application(s)")
		}
		if result != nil && len(*result) > 0 {
			existingApp := (*result)[0]
			if existingApp.Id == nil {
				return tf.ErrorDiagF(errors.New("API returned application with nil object ID during duplicate name check"), "Bad API response")
			}
			return tf.ImportAsDuplicateDiag("azuread_application", *existingApp.Id, displayName)
		}
	}

	var imageContentType string
	var imageData []byte
	if v, ok := d.GetOk("logo_image"); ok && v != "" {
		var err error
		imageContentType, imageData, err = applicationParseLogoImage(v.(string))
		if err != nil {
			return tf.ErrorDiagPathF(err, "image", "Could not decode image data")
		}
	}

	var tags []string
	if v, ok := d.GetOk("feature_tags"); ok {
		tags = applications.ExpandFeatures(v.([]interface{}))
	} else {
		tags = tf.ExpandStringSlice(d.Get("tags").(*pluginsdk.Set).List())
	}

	if appTemplateId := d.Get("template_id").(string); appTemplateId != "" {
		// Validate the template exists
		templateId := stable.NewApplicationTemplateID(appTemplateId)
		if resp, err := appTemplateClient.GetApplicationTemplate(ctx, templateId, applicationtemplate.DefaultGetApplicationTemplateOperationOptions()); err != nil {
			if response.WasNotFound(resp.HttpResponse) {
				return tf.ErrorDiagPathF(err, "template_id", "Could not find %s", templateId)
			}
			return tf.ErrorDiagF(err, "retrieving %s", templateId)
		}

		// Generate a temporary display name to assert uniqueness when handling buggy 404 when instantiating
		uuid, err := uuid.GenerateUUID()
		if err != nil {
			return tf.ErrorDiagF(err, "Failed to generate a UUID")
		}
		tempDisplayName := fmt.Sprintf("TERRAFORM_INSTANTIATE_%s", uuid)

		// Instantiate application from template gallery and return via the update function
		properties := applicationtemplate.InstantiateRequest{
			DisplayName: nullable.Value(tempDisplayName),
		}

		// When the /instantiate operation returns 404, it has probably created the application anyway. There is no way to tell this
		// other than polling for the application object which is created out-of-band, so we create it with a quasi-unique temporary
		// displayName and then poll for it.
		resp, err := appTemplateClient.Instantiate(ctx, templateId, properties, applicationtemplate.DefaultInstantiateOperationOptions())
		var applicationServicePrincipal *stable.ApplicationServicePrincipal
		if resp.Model != nil {
			applicationServicePrincipal = &stable.ApplicationServicePrincipal{
				Application:      resp.Model.Application,
				ServicePrincipal: resp.Model.ServicePrincipal,
			}
		}

		if err != nil {
			if response.WasNotFound(resp.HttpResponse) {
				// Since a 404 response is misleading, we'll log that we got the error, but proceed to polling anyway
				log.Printf("[WARN] Received a 404 error when instantiating application from template, but proceeding anyway by polling for the created application and service principal")
			} else {
				return tf.ErrorDiagF(err, "Could not instantiate application from template")
			}
		}

		deadline, ok := ctx.Deadline()
		if !ok {
			return tf.ErrorDiagF(errors.New("context has no deadline"), "internal-error: context has no deadline")
		}

		// Since the API response can't be trusted, because we might have received a 404, or the response model might be missing,
		// we'll proceed to poll for an application and service principal by listing them and looking for a match.
		pollingResult, err := (&pluginsdk.StateChangeConf{ //nolint:staticcheck
			Pending:    []string{"Waiting"},
			Target:     []string{"Found"},
			Timeout:    time.Until(deadline),
			MinTimeout: 5 * time.Second,
			Refresh: func() (interface{}, string, error) {
				// List applications with matching applicationTemplateId and displayName (using the temporary display name we generated above)
				options := application.ListApplicationsOperationOptions{
					Filter: pointer.To(fmt.Sprintf("applicationTemplateId eq '%s' and displayName eq '%s'", odata.EscapeSingleQuote(appTemplateId), odata.EscapeSingleQuote(tempDisplayName))),
				}
				resp, err := client.ListApplications(ctx, options)
				if err != nil {
					return nil, "Error", err
				}
				if resp.Model == nil {
					return nil, "Waiting", nil
				}

				for _, app := range *resp.Model {
					if id := app.Id; id != nil && !app.AppId.IsNull() && app.ApplicationTemplateId.GetOrZero() == appTemplateId && app.DisplayName.GetOrZero() == tempDisplayName {
						applicationId := stable.NewApplicationID(*id)

						// Now ensure we can retrieve the application consistently
						if err = consistency.WaitForUpdate(ctx, func(ctx context.Context) (*bool, error) {
							resp, err := client.GetApplication(ctx, applicationId, application.DefaultGetApplicationOperationOptions())
							if err != nil {
								if response.WasNotFound(resp.HttpResponse) {
									return pointer.To(false), nil
								}
								return pointer.To(false), err
							}
							return pointer.To(resp.Model != nil), nil
						}); err != nil {
							return nil, "Error", fmt.Errorf("polling for %s", applicationId)
						}

						// We should ensure the service principal was also created, so list service principals for the created application
						servicePrincipalsOptions := serviceprincipal.ListServicePrincipalsOperationOptions{
							Filter: pointer.To(fmt.Sprintf("appId eq '%s'", odata.EscapeSingleQuote(app.AppId.GetOrZero()))),
						}
						servicePrincipalsResp, err := servicePrincipalsClient.ListServicePrincipals(ctx, servicePrincipalsOptions)
						if err != nil {
							return nil, "Error", err
						}
						if servicePrincipalsResp.Model == nil {
							return nil, "Waiting", nil
						}

						for _, servicePrincipal := range *servicePrincipalsResp.Model {
							// Validate the appId and applicationTemplateId match the application
							if servicePrincipalId := servicePrincipal.Id; servicePrincipalId != nil && servicePrincipal.AppId.GetOrZero() == app.AppId.GetOrZero() && servicePrincipal.ApplicationTemplateId.GetOrZero() == appTemplateId {

								// Now we have found the application and service principal construct an ApplicationServicePrincipal
								// struct as we _should_ be getting from the Instantiate API.
								return stable.ApplicationServicePrincipal{
									Application:      &app,
									ServicePrincipal: &servicePrincipal,
								}, "Found", nil
							}
						}
					}
				}
				return nil, "Waiting", nil
			},
		}).WaitForStateContext(ctx)

		if err != nil {
			return tf.ErrorDiagF(err, "Could not instantiate application from template")
		}
		if pollingResult == nil {
			return tf.ErrorDiagF(errors.New("attempted to poll for application and service principal but they were not found"), "Could not instantiate application from template")
		}

		// Reassign result from the Instantiate operation using the application and service principal that we polled for
		if template, ok := pollingResult.(stable.ApplicationServicePrincipal); ok {
			applicationServicePrincipal = &template
		}

		if applicationServicePrincipal.Application == nil {
			return tf.ErrorDiagF(errors.New("Bad API response"), "Nil application object returned for instantiated application")
		}

		if applicationServicePrincipal.Application.Id == nil || *applicationServicePrincipal.Application.Id == "" {
			return tf.ErrorDiagF(errors.New("Bad API response"), "Object ID returned for instantiated application is nil/empty")
		}

		id := stable.NewApplicationID(*applicationServicePrincipal.Application.Id)
		d.SetId(id.ID())

		// The application was created out of band, so we'll update it just as if it was imported. This will also
		// set the correct displayName for the application.
		return applicationResourceUpdate(ctx, d, meta)
	}

	api := expandApplicationApi(d.Get("api").([]interface{}))

	// API bug: cannot set `acceptMappedClaims` when holding the Application.ReadWrite.OwnedBy role
	// See https://github.com/hashicorp/terraform-provider-azuread/issues/914
	var acceptMappedClaims nullable.Type[bool]
	if api.AcceptMappedClaims.GetOrZero() {
		acceptMappedClaims = api.AcceptMappedClaims
		api.AcceptMappedClaims = nil
	}

	// Create a new application
	properties := stable.Application{
		Api:                   api,
		AppRoles:              expandApplicationAppRoles(d.Get("app_role").(*pluginsdk.Set).List()),
		Description:           nullable.NoZero(d.Get("description").(string)),
		DisplayName:           nullable.Value(displayName),
		GroupMembershipClaims: expandApplicationGroupMembershipClaims(d.Get("group_membership_claims").(*pluginsdk.Set).List()),
		IdentifierUris:        tf.ExpandStringSlicePtr(d.Get("identifier_uris").(*pluginsdk.Set).List()),
		Info: &stable.InformationalUrl{
			MarketingUrl:        nullable.NoZero(d.Get("marketing_url").(string)),
			PrivacyStatementUrl: nullable.NoZero(d.Get("privacy_statement_url").(string)),
			SupportUrl:          nullable.NoZero(d.Get("support_url").(string)),
			TermsOfServiceUrl:   nullable.NoZero(d.Get("terms_of_service_url").(string)),
		},
		IsDeviceOnlyAuthSupported:  nullable.Value(d.Get("device_only_auth_enabled").(bool)),
		IsFallbackPublicClient:     nullable.Value(d.Get("fallback_public_client_enabled").(bool)),
		Notes:                      nullable.NoZero(d.Get("notes").(string)),
		OptionalClaims:             expandApplicationOptionalClaims(d.Get("optional_claims").([]interface{})),
		PublicClient:               expandApplicationPublicClient(d.Get("public_client").([]interface{})),
		RequiredResourceAccess:     expandApplicationRequiredResourceAccess(d.Get("required_resource_access").(*pluginsdk.Set).List()),
		ServiceManagementReference: nullable.NoZero(d.Get("service_management_reference").(string)),
		SignInAudience:             nullable.Value(d.Get("sign_in_audience").(string)),
		Spa:                        expandApplicationSpa(d.Get("single_page_application").([]interface{})),
		Tags:                       &tags,
		Web:                        expandApplicationWeb(d.Get("web").([]interface{})),
	}

	// Generate an application password, if specified
	if v, ok := d.GetOk("password"); ok {
		password := v.(*pluginsdk.Set).List()
		if len(password) > 1 {
			return tf.ErrorDiagPathF(errors.New("`password` must have one element"), "password", "Multiple passwords are not supported with this resource")
		}

		credentials, err := expandApplicationPasswordCredentials(password)
		if err != nil {
			return tf.ErrorDiagPathF(err, "password", "Could not flatten application password credentials")
		}

		properties.PasswordCredentials = credentials
	}

	// Sort the owners into two slices, the first containing up to 20 and the rest overflowing to the second slice
	// The calling principal should always be in the first slice of owners
	callerId := meta.(*clients.Client).ObjectID

	ownersFirst20 := []string{fmt.Sprintf("%s%s", client.Client.BaseUri, stable.NewDirectoryObjectID(callerId).ID())}
	var ownersExtra []stable.ReferenceCreate

	// Track whether we need to remove the calling principal later on
	removeCallerOwner := true

	// Retrieve and set the initial owners, which can be up to 20 in total when creating the application
	if v, ok := d.GetOk("owners"); ok {
		ownerCount := 0
		for _, ownerIdRaw := range v.(*pluginsdk.Set).List() {
			ownerId := ownerIdRaw.(string)

			// If the calling principal was found in the specified owners, we won't remove them later
			if strings.EqualFold(ownerId, callerId) {
				removeCallerOwner = false
				continue
			}

			if ownerCount < 19 {
				ownersFirst20 = append(ownersFirst20, client.Client.BaseUri+stable.NewDirectoryObjectID(ownerId).ID())
			} else {
				ownerObject := stable.ReferenceCreate{
					ODataId: pointer.To(client.Client.BaseUri + stable.NewDirectoryObjectID(ownerId).ID()),
				}
				ownersExtra = append(ownersExtra, ownerObject)
			}
			ownerCount++
		}
	}

	// Set the initial owners, which should include the calling principal plus up to 19 of owners specified in configuration
	properties.Owners_ODataBind = &ownersFirst20

	resp, err := client.CreateApplication(ctx, properties, application.DefaultCreateApplicationOperationOptions())
	if err != nil {
		return tf.ErrorDiagF(err, "Could not create application")
	}

	app := resp.Model
	if app.Id == nil || *app.Id == "" {
		return tf.ErrorDiagF(errors.New("Bad API response"), "Object ID returned for application is nil/empty")
	}

	id := stable.NewApplicationID(*app.Id)
	betaId := beta.NewApplicationID(*app.Id)
	d.SetId(id.ID())

	// Save the password key ID and generated value to state
	if app.PasswordCredentials != nil {
		if password := d.Get("password").(*pluginsdk.Set).List(); len(password) == 1 {
			pw := password[0].(map[string]interface{})
			if creds := flattenApplicationPasswordCredentials(app.PasswordCredentials); len(creds) == 1 {
				pw["key_id"] = creds[0]["key_id"]
				pw["value"] = creds[0]["value"]
				tf.Set(d, "password", []interface{}{pw})
			}
		}
	}

	// Attempt to patch the newly created application and set the display name, which will tell us whether it exists yet, then set it back to the desired value.
	// The SDK handles retries for us here in the event of 404, 429 or 5xx, then returns after giving up.
	uid, err := uuid.GenerateUUID()
	if err != nil {
		return tf.ErrorDiagF(err, "Failed to generate a UUID")
	}
	tempDisplayName := fmt.Sprintf("TERRAFORM_UPDATE_%s", uid)
	for _, displayNameToSet := range []string{tempDisplayName, displayName} {
		resp, err := client.UpdateApplication(ctx, id, stable.Application{
			DisplayName: nullable.Value(displayNameToSet),
		}, application.UpdateApplicationOperationOptions{
			RetryFunc: applicationUpdateRetryFunc(),
		})
		if err != nil {
			if response.WasNotFound(resp.HttpResponse) {
				return tf.ErrorDiagF(err, "Timed out whilst waiting for new application to be replicated in Azure AD")
			}
			return tf.ErrorDiagF(err, "Failed to patch application with object ID %q after creating", id.ApplicationId)
		}
	}

	// API bug: the v1.0 API does not recognize the `oauth2RequiredPostResponse` field, so set it using the beta API
	// See https://github.com/microsoftgraph/msgraph-metadata/issues/273
	if oauth2PostResponseRequired, ok := d.GetOkExists("oauth2_post_response_required"); ok { //nolint:staticcheck
		if _, err := clientBeta.UpdateApplication(ctx, betaId, beta.Application{
			OAuth2RequirePostResponse: pointer.To(oauth2PostResponseRequired.(bool)),
		}, applicationBeta.UpdateApplicationOperationOptions{
			RetryFunc: applicationUpdateRetryFunc(),
		}); err != nil {
			return tf.ErrorDiagF(err, "Failed to set `oauth2_post_response_required` for %s", id)
		}
	}

	// API bug: cannot set `acceptMappedClaims` when holding the Application.ReadWrite.OwnedBy role
	// See https://github.com/hashicorp/terraform-provider-azuread/issues/914
	if !acceptMappedClaims.IsNull() && acceptMappedClaims.IsSet() {
		api.AcceptMappedClaims = acceptMappedClaims
		if _, err = client.UpdateApplication(ctx, id, stable.Application{Api: api}, application.UpdateApplicationOperationOptions{
			RetryFunc: applicationUpdateRetryFunc(),
		}); err != nil {
			return tf.ErrorDiagPathF(err, "api.0.mapped_claims_enabled", "Failed to patch application after creating to set `api.0.mapped_claims_enabled` property")
		}
	}

	// Add any remaining owners after the application is created
	for _, ref := range ownersExtra {
		if _, err = ownerClient.AddOwnerRef(ctx, id, ref, owner.DefaultAddOwnerRefOperationOptions()); err != nil {
			return tf.ErrorDiagF(err, "Could not add owners to application with object ID: %q", id.ApplicationId)
		}
	}

	// If the calling principal was not included in configuration, remove it now
	if removeCallerOwner {
		ownerId := stable.NewApplicationIdOwnerID(id.ApplicationId, callerId)
		if _, err = ownerClient.RemoveOwnerRef(ctx, ownerId, owner.DefaultRemoveOwnerRefOperationOptions()); err != nil {
			return tf.ErrorDiagF(err, "Could not remove initial owner from application with object ID: %q", id.ApplicationId)
		}
	}

	// Upload the application image
	if imageContentType != "" && len(imageData) > 0 {
		if _, err = logoClient.SetLogo(ctx, id, imageData, logo.SetLogoOperationOptions{
			ContentType: imageContentType,
		}); err != nil {
			return tf.ErrorDiagF(err, "Could not upload logo image for application with object ID: %q", id.ApplicationId)
		}
	}

	return applicationResourceRead(ctx, d, meta)
}
