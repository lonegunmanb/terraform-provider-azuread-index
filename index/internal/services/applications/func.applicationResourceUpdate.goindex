package github.com/hashicorp/terraform-provider-azuread/internal/services/applications
import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-sdk/sdk/odata"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-provider-azuread/internal/clients"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers"
	"github.com/hashicorp/terraform-provider-azuread/internal/services/applications/migrations"
	"github.com/hashicorp/terraform-provider-azuread/internal/services/applications/parse"
	applicationsValidate "github.com/hashicorp/terraform-provider-azuread/internal/services/applications/validate"
	"github.com/hashicorp/terraform-provider-azuread/internal/tf"
	"github.com/hashicorp/terraform-provider-azuread/internal/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azuread/internal/tf/validation"
	"github.com/manicminer/hamilton/msgraph"
)
func applicationResourceUpdate(ctx context.Context, d *pluginsdk.ResourceData, meta interface{}) pluginsdk.Diagnostics {
	client := meta.(*clients.Client).Applications.ApplicationsClientBeta
	tenantId := meta.(*clients.Client).TenantID

	id, err := parse.ParseApplicationID(d.Id())
	if err != nil {
		return tf.ErrorDiagPathF(err, "id", "Parsing ID")
	}

	tf.LockByName(applicationResourceName, id.ApplicationId)
	defer tf.UnlockByName(applicationResourceName, id.ApplicationId)

	displayName := d.Get("display_name").(string)

	// Perform this check at apply time to catch any duplicate names created during the same apply
	if d.Get("prevent_duplicate_names").(bool) {
		result, err := applicationFindByName(ctx, client, displayName)
		if err != nil {
			return tf.ErrorDiagPathF(err, "display_name", "Could not check for existing application(s)")
		}
		if result != nil && len(*result) > 0 {
			for _, existingApp := range *result {
				if existingApp.ID() == nil {
					return tf.ErrorDiagF(errors.New("API returned application with nil object ID during duplicate name check"), "Bad API response")
				}

				if *existingApp.ID() != id.ApplicationId {
					return tf.ImportAsDuplicateDiag("azuread_application", *existingApp.ID(), displayName)
				}
			}
		}
	}

	var imageContentType string
	var imageData []byte
	if v, ok := d.GetOk("logo_image"); ok && v != "" && d.HasChange("logo_image") {
		imageContentType, imageData, err = applicationParseLogoImage(v.(string))
		if err != nil {
			return tf.ErrorDiagPathF(err, "image", "Could not decode image data")
		}
	}

	// Remove and/or set a new application password, if changed
	if d.HasChange("password") {
		oldPasswordRaw, newPasswordRaw := d.GetChange("password")
		oldPasswordBlock := oldPasswordRaw.(*pluginsdk.Set).List()
		oldPassword := make(map[string]interface{})
		if len(oldPasswordBlock) > 0 {
			oldPassword = oldPasswordBlock[0].(map[string]interface{})
		}

		if oldPassword["key_id"] != nil {
			keyIdToRemove := oldPassword["key_id"].(string)
			if _, err = client.RemovePassword(ctx, id.ApplicationId, keyIdToRemove); err != nil {
				return tf.ErrorDiagF(err, "Removing password credential %q from application with object ID %q", id.ApplicationId, keyIdToRemove)
			}

			// Wait for application password to be deleted
			if err = helpers.WaitForDeletion(ctx, func(ctx context.Context) (*bool, error) {
				defer func() { client.BaseClient.DisableRetries = false }()
				client.BaseClient.DisableRetries = true

				app, _, err := client.Get(ctx, id.ApplicationId, odata.Query{})
				if err != nil {
					return nil, err
				}

				credential := helpers.GetPasswordCredential(app.PasswordCredentials, keyIdToRemove)
				if credential == nil {
					return pointer.To(false), nil
				}

				return pointer.To(true), nil
			}); err != nil {
				return tf.ErrorDiagF(err, "Waiting for deletion of password credential %q from application with object ID %q", keyIdToRemove, id.ApplicationId)
			}
		}

		newPasswordBlock := newPasswordRaw.(*pluginsdk.Set).List()
		if len(newPasswordBlock) > 1 {
			return tf.ErrorDiagPathF(errors.New("`password` must have one element"), "password", "Multiple passwords are not supported with this resource")
		}

		// Proceed to add a new password to replace the now-removed one, if the password block is present in the configuration
		if len(newPasswordBlock) > 0 {
			newPassword := newPasswordBlock[0].(map[string]interface{})

			credential, err := helpers.PasswordCredential(newPassword)
			if err != nil {
				attr := ""
				if kerr, ok := err.(helpers.CredentialError); ok {
					attr = kerr.Attr()
				}
				return tf.ErrorDiagPathF(err, attr, "Generating password credential for %s", id.ApplicationId)
			}

			newCredential, _, err := client.AddPassword(ctx, id.ApplicationId, *credential)
			if err != nil {
				return tf.ErrorDiagF(err, "Adding password for application with object ID %q", id.ApplicationId)
			}
			if newCredential == nil {
				return tf.ErrorDiagF(errors.New("nil credential received when adding password"), "API error adding password for application with object ID %q", id.ApplicationId)
			}
			if newCredential.KeyId == nil {
				return tf.ErrorDiagF(errors.New("nil or empty keyId received"), "API error adding password for application with object ID %q", id.ApplicationId)
			}
			if newCredential.SecretText == nil || len(*newCredential.SecretText) == 0 {
				return tf.ErrorDiagF(errors.New("nil or empty password received"), "API error adding password for application with object ID %q", id.ApplicationId)
			}

			// Wait for the credential to appear in the application manifest, this can take several minutes
			timeout, _ := ctx.Deadline()
			polledForCredential, err := (&pluginsdk.StateChangeConf{ //nolint:staticcheck
				Pending:                   []string{"Waiting"},
				Target:                    []string{"Done"},
				Timeout:                   time.Until(timeout),
				MinTimeout:                1 * time.Second,
				ContinuousTargetOccurence: 5,
				Refresh: func() (interface{}, string, error) {
					app, _, err := client.Get(ctx, id.ApplicationId, odata.Query{})
					if err != nil {
						return nil, "Error", err
					}

					if app.PasswordCredentials != nil {
						for _, cred := range *app.PasswordCredentials {
							if cred.KeyId != nil && strings.EqualFold(*cred.KeyId, *newCredential.KeyId) {
								return &cred, "Done", nil
							}
						}
					}

					return nil, "Waiting", nil
				},
			}).WaitForStateContext(ctx)

			if err != nil {
				return tf.ErrorDiagF(err, "Waiting for password credential for application with object ID %q", id.ApplicationId)
			} else if polledForCredential == nil {
				return tf.ErrorDiagF(errors.New("password credential not found in application manifest"), "Waiting for password credential for application with object ID %q", id.ApplicationId)
			}

			// Ensure the new value is persisted to state
			newPassword["key_id"] = pointer.From(newCredential.KeyId)
			newPassword["value"] = pointer.From(newCredential.SecretText)
			tf.Set(d, "password", []interface{}{newPassword})
		}
	}

	var tags []string
	if v, ok := d.GetOk("feature_tags"); ok && len(v.([]interface{})) > 0 && d.HasChange("feature_tags") {
		tags = helpers.ApplicationExpandFeatures(v.([]interface{}))
	} else {
		tags = tf.ExpandStringSlice(d.Get("tags").(*pluginsdk.Set).List())
	}

	properties := msgraph.Application{
		DirectoryObject: msgraph.DirectoryObject{
			Id: pointer.To(id.ApplicationId),
		},
		Description:           tf.NullableString(d.Get("description").(string)),
		DisplayName:           pointer.To(displayName),
		GroupMembershipClaims: expandApplicationGroupMembershipClaims(d.Get("group_membership_claims").(*pluginsdk.Set).List()),
		Info: &msgraph.InformationalUrl{
			MarketingUrl:        tf.NullableString(d.Get("marketing_url").(string)),
			PrivacyStatementUrl: tf.NullableString(d.Get("privacy_statement_url").(string)),
			SupportUrl:          tf.NullableString(d.Get("support_url").(string)),
			TermsOfServiceUrl:   tf.NullableString(d.Get("terms_of_service_url").(string)),
		},
		IsDeviceOnlyAuthSupported:  pointer.To(d.Get("device_only_auth_enabled").(bool)),
		IsFallbackPublicClient:     pointer.To(d.Get("fallback_public_client_enabled").(bool)),
		Notes:                      tf.NullableString(d.Get("notes").(string)),
		Oauth2RequirePostResponse:  pointer.To(d.Get("oauth2_post_response_required").(bool)),
		PublicClient:               expandApplicationPublicClient(d.Get("public_client").([]interface{})),
		ServiceManagementReference: tf.NullableString(d.Get("service_management_reference").(string)),
		SignInAudience:             pointer.To(d.Get("sign_in_audience").(string)),
		Spa:                        expandApplicationSpa(d.Get("single_page_application").([]interface{})),
		Tags:                       &tags,
		Web:                        expandApplicationWeb(d.Get("web").([]interface{})),
	}

	api := expandApplicationApi(d.Get("api").([]interface{}))

	if d.HasChange("app_role") {
		if err = applicationDisableAppRoles(ctx, client, &properties, expandApplicationAppRoles(d.Get("app_role").(*pluginsdk.Set).List())); err != nil {
			return tf.ErrorDiagPathF(err, "app_role", "Could not disable App Roles for application with object ID %q", id.ApplicationId)
		}

		properties.AppRoles = expandApplicationAppRoles(d.Get("app_role").(*pluginsdk.Set).List())
	}

	if d.HasChange("api.0.oauth2_permission_scope") {
		if err = applicationDisableOauth2PermissionScopes(ctx, client, &properties, expandApplicationOAuth2PermissionScope(d.Get("api.0.oauth2_permission_scope").(*pluginsdk.Set).List())); err != nil {
			return tf.ErrorDiagPathF(err, "api.0.oauth2_permission_scope", "Could not disable OAuth2 Permission Scopes for application with object ID %q", id.ApplicationId)
		}
	} else {
		api.OAuth2PermissionScopes = nil
	}

	if d.HasChange("identifier_uris") {
		properties.IdentifierUris = tf.ExpandStringSlicePtr(d.Get("identifier_uris").(*pluginsdk.Set).List())
	}

	if d.HasChange("optional_claims") {
		properties.OptionalClaims = expandApplicationOptionalClaims(d.Get("optional_claims").([]interface{}))
	}

	if d.HasChange("required_resource_access") {
		properties.RequiredResourceAccess = expandApplicationRequiredResourceAccess(d.Get("required_resource_access").(*pluginsdk.Set).List())
	}

	properties.Api = api

	if _, err = client.Update(ctx, properties); err != nil {
		return tf.ErrorDiagF(err, "Could not update application with object ID: %q", id.ApplicationId)
	}

	if d.HasChange("owners") {
		owners, _, err := client.ListOwners(ctx, id.ApplicationId)
		if err != nil {
			return tf.ErrorDiagF(err, "Could not retrieve owners for application with object ID: %q", id.ApplicationId)
		}

		desiredOwners := *tf.ExpandStringSlicePtr(d.Get("owners").(*pluginsdk.Set).List())
		existingOwners := *owners
		ownersForRemoval := tf.Difference(existingOwners, desiredOwners)
		ownersToAdd := tf.Difference(desiredOwners, existingOwners)

		if len(ownersToAdd) > 0 {
			newOwners := make(msgraph.Owners, 0)
			for _, ownerId := range ownersToAdd {
				newOwners = append(newOwners, msgraph.DirectoryObject{
					ODataId: (*odata.Id)(pointer.To(fmt.Sprintf("%s/v1.0/%s/directoryObjects/%s",
						client.BaseClient.Endpoint, tenantId, ownerId))),
					Id: &ownerId,
				})
			}

			properties.Owners = &newOwners
			if _, err = client.AddOwners(ctx, &properties); err != nil {
				return tf.ErrorDiagF(err, "Could not add owners to application with object ID: %q", id.ApplicationId)
			}
		}

		if len(ownersForRemoval) > 0 {
			if _, err = client.RemoveOwners(ctx, id.ApplicationId, &ownersForRemoval); err != nil {
				return tf.ErrorDiagF(err, "Could not remove owners from application with object ID: %q", id.ApplicationId)
			}
		}
	}

	// Upload the application image
	if imageContentType != "" && len(imageData) > 0 {
		if _, err = client.UploadLogo(ctx, id.ApplicationId, imageContentType, imageData); err != nil {
			return tf.ErrorDiagF(err, "Could not upload logo image for application with object ID: %q", id.ApplicationId)
		}
	}

	return applicationResourceRead(ctx, d, meta)
}
