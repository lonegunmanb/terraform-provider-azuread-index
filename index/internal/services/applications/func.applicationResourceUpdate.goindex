package github.com/hashicorp/terraform-provider-azuread/internal/services/applications
import (
	"context"
	"errors"
	"fmt"
	"log"
	"net/url"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-helpers/lang/pointer"
	"github.com/hashicorp/go-azure-helpers/lang/response"
	applicationBeta "github.com/hashicorp/go-azure-sdk/microsoft-graph/applications/beta/application"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/applications/stable/application"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/applications/stable/logo"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/applications/stable/owner"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/applicationtemplates/stable/applicationtemplate"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/common-types/beta"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/common-types/stable"
	"github.com/hashicorp/go-azure-sdk/microsoft-graph/serviceprincipals/stable/serviceprincipal"
	"github.com/hashicorp/go-azure-sdk/sdk/nullable"
	"github.com/hashicorp/go-azure-sdk/sdk/odata"
	"github.com/hashicorp/go-cty/cty"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-provider-azuread/internal/clients"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/applications"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/consistency"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/credentials"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf/pluginsdk"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf/validation"
	"github.com/hashicorp/terraform-provider-azuread/internal/services/applications/migrations"
	applicationsValidate "github.com/hashicorp/terraform-provider-azuread/internal/services/applications/validate"
)
func applicationResourceUpdate(ctx context.Context, d *pluginsdk.ResourceData, meta interface{}) pluginsdk.Diagnostics {
	client := meta.(*clients.Client).Applications.ApplicationClient
	clientBeta := meta.(*clients.Client).Applications.ApplicationClientBeta
	logoClient := meta.(*clients.Client).Applications.ApplicationLogoClient
	ownerClient := meta.(*clients.Client).Applications.ApplicationOwnerClient

	id, err := stable.ParseApplicationID(d.Id())
	if err != nil {
		return tf.ErrorDiagPathF(err, "id", "Parsing ID")
	}

	betaId := beta.NewApplicationID(id.ApplicationId)

	tf.LockByName(applicationResourceName, id.ApplicationId)
	defer tf.UnlockByName(applicationResourceName, id.ApplicationId)

	displayName := d.Get("display_name").(string)

	// Perform this check at apply time to catch any duplicate names created during the same apply
	if d.Get("prevent_duplicate_names").(bool) {
		result, err := applicationFindByName(ctx, client, displayName)
		if err != nil {
			return tf.ErrorDiagPathF(err, "display_name", "Could not check for existing application(s)")
		}
		if result != nil && len(*result) > 0 {
			for _, existingApp := range *result {
				if existingApp.Id == nil {
					return tf.ErrorDiagF(errors.New("API returned application with nil object ID during duplicate name check"), "Bad API response")
				}

				if *existingApp.Id != id.ApplicationId {
					return tf.ImportAsDuplicateDiag("azuread_application", *existingApp.Id, displayName)
				}
			}
		}
	}

	var imageContentType string
	var imageData []byte
	if v, ok := d.GetOk("logo_image"); ok && v != "" && d.HasChange("logo_image") {
		imageContentType, imageData, err = applicationParseLogoImage(v.(string))
		if err != nil {
			return tf.ErrorDiagPathF(err, "image", "Could not decode image data")
		}
	}

	// Remove and/or set a new application password, if changed
	if d.HasChange("password") {
		oldPasswordRaw, newPasswordRaw := d.GetChange("password")
		oldPasswordBlock := oldPasswordRaw.(*pluginsdk.Set).List()
		oldPassword := make(map[string]interface{})
		if len(oldPasswordBlock) > 0 {
			oldPassword = oldPasswordBlock[0].(map[string]interface{})
		}

		if oldPassword["key_id"] != nil {
			keyIdToRemove := oldPassword["key_id"].(string)
			if _, err = client.RemovePassword(ctx, *id, application.RemovePasswordRequest{
				KeyId: pointer.To(keyIdToRemove),
			}, application.DefaultRemovePasswordOperationOptions()); err != nil {
				return tf.ErrorDiagF(err, "Removing password credential %q from application with object ID %q", id.ApplicationId, keyIdToRemove)
			}

			// Wait for application password to be deleted
			if err = consistency.WaitForDeletion(ctx, func(ctx context.Context) (*bool, error) {
				resp, err := client.GetApplication(ctx, *id, application.DefaultGetApplicationOperationOptions())
				if err != nil {
					return nil, err
				}

				app := resp.Model
				if app == nil {
					return nil, errors.New("model was nil")
				}

				credential := credentials.GetPasswordCredential(app.PasswordCredentials, keyIdToRemove)
				if credential == nil {
					return pointer.To(false), nil
				}

				return pointer.To(true), nil
			}); err != nil {
				return tf.ErrorDiagF(err, "Waiting for deletion of password credential %q from application with object ID %q", keyIdToRemove, id.ApplicationId)
			}
		}

		newPasswordBlock := newPasswordRaw.(*pluginsdk.Set).List()
		if len(newPasswordBlock) > 1 {
			return tf.ErrorDiagPathF(errors.New("`password` must have one element"), "password", "Multiple passwords are not supported with this resource")
		}

		// Proceed to add a new password to replace the now-removed one, if the password block is present in the configuration
		if len(newPasswordBlock) > 0 {
			newPassword := newPasswordBlock[0].(map[string]interface{})

			credential, err := credentials.PasswordCredential(newPassword)
			if err != nil {
				attr := ""
				if kerr, ok := err.(credentials.CredentialError); ok {
					attr = kerr.Attr()
				}
				return tf.ErrorDiagPathF(err, attr, "Generating password credential for %s", id.ApplicationId)
			}

			resp, err := client.AddPassword(ctx, *id, application.AddPasswordRequest{
				PasswordCredential: credential,
			}, application.DefaultAddPasswordOperationOptions())
			if err != nil {
				return tf.ErrorDiagF(err, "Adding password for application with object ID %q", id.ApplicationId)
			}

			newCredential := resp.Model
			if newCredential == nil {
				return tf.ErrorDiagF(errors.New("nil credential received when adding password"), "API error adding password for application with object ID %q", id.ApplicationId)
			}
			if newCredential.KeyId == nil {
				return tf.ErrorDiagF(errors.New("nil or empty keyId received"), "API error adding password for application with object ID %q", id.ApplicationId)
			}
			if len(newCredential.SecretText.GetOrZero()) == 0 {
				return tf.ErrorDiagF(errors.New("nil or empty password received"), "API error adding password for application with object ID %q", id.ApplicationId)
			}

			// Wait for the credential to appear in the application manifest, this can take several minutes
			timeout, _ := ctx.Deadline()
			polledForCredential, err := (&pluginsdk.StateChangeConf{ //nolint:staticcheck
				Pending:                   []string{"Waiting"},
				Target:                    []string{"Done"},
				Timeout:                   time.Until(timeout),
				MinTimeout:                1 * time.Second,
				ContinuousTargetOccurence: 5,
				Refresh: func() (interface{}, string, error) {
					resp, err := client.GetApplication(ctx, *id, application.DefaultGetApplicationOperationOptions())
					if err != nil {
						return nil, "Error", err
					}

					app := resp.Model
					if app == nil {
						return nil, "Error", errors.New("model was nil")
					}

					if app.PasswordCredentials != nil {
						for _, cred := range *app.PasswordCredentials {
							if strings.EqualFold(cred.KeyId.GetOrZero(), newCredential.KeyId.GetOrZero()) {
								return &cred, "Done", nil
							}
						}
					}

					return nil, "Waiting", nil
				},
			}).WaitForStateContext(ctx)

			if err != nil {
				return tf.ErrorDiagF(err, "Waiting for password credential for application with object ID %q", id.ApplicationId)
			} else if polledForCredential == nil {
				return tf.ErrorDiagF(errors.New("password credential not found in application manifest"), "Waiting for password credential for application with object ID %q", id.ApplicationId)
			}

			// Ensure the new value is persisted to state
			newPassword["key_id"] = newCredential.KeyId.GetOrZero()
			newPassword["value"] = newCredential.SecretText.GetOrZero()
			tf.Set(d, "password", []interface{}{newPassword})
		}
	}

	var tags []string
	if v, ok := d.GetOk("feature_tags"); ok && len(v.([]interface{})) > 0 && d.HasChange("feature_tags") {
		tags = applications.ExpandFeatures(v.([]interface{}))
	} else {
		tags = tf.ExpandStringSlice(d.Get("tags").(*pluginsdk.Set).List())
	}

	properties := stable.Application{
		Description:           nullable.NoZero(d.Get("description").(string)),
		DisplayName:           nullable.Value(displayName),
		GroupMembershipClaims: expandApplicationGroupMembershipClaims(d.Get("group_membership_claims").(*pluginsdk.Set).List()),
		Info: &stable.InformationalUrl{
			MarketingUrl:        nullable.NoZero(d.Get("marketing_url").(string)),
			PrivacyStatementUrl: nullable.NoZero(d.Get("privacy_statement_url").(string)),
			SupportUrl:          nullable.NoZero(d.Get("support_url").(string)),
			TermsOfServiceUrl:   nullable.NoZero(d.Get("terms_of_service_url").(string)),
		},
		IsDeviceOnlyAuthSupported:  nullable.Value(d.Get("device_only_auth_enabled").(bool)),
		IsFallbackPublicClient:     nullable.Value(d.Get("fallback_public_client_enabled").(bool)),
		Notes:                      nullable.NoZero(d.Get("notes").(string)),
		PublicClient:               expandApplicationPublicClient(d.Get("public_client").([]interface{})),
		ServiceManagementReference: nullable.NoZero(d.Get("service_management_reference").(string)),
		SignInAudience:             nullable.Value(d.Get("sign_in_audience").(string)),
		Spa:                        expandApplicationSpa(d.Get("single_page_application").([]interface{})),
		Tags:                       &tags,
		Web:                        expandApplicationWeb(d.Get("web").([]interface{})),
	}

	api := expandApplicationApi(d.Get("api").([]interface{}))

	if d.HasChange("app_role") {
		appRoles := expandApplicationAppRoles(d.Get("app_role").(*pluginsdk.Set).List())
		if err = applicationDisableAppRoles(ctx, client, *id, appRoles); err != nil {
			return tf.ErrorDiagPathF(err, "app_role", "Could not disable App Roles for application with object ID %q", id.ApplicationId)
		}

		properties.AppRoles = expandApplicationAppRoles(d.Get("app_role").(*pluginsdk.Set).List())
	}

	if d.HasChange("api.0.oauth2_permission_scope") {
		scopes := expandApplicationOAuth2PermissionScope(d.Get("api.0.oauth2_permission_scope").(*pluginsdk.Set).List())
		if err = applicationDisableOauth2PermissionScopes(ctx, client, *id, scopes); err != nil {
			return tf.ErrorDiagPathF(err, "api.0.oauth2_permission_scope", "Could not disable OAuth2 Permission Scopes for application with object ID %q", id.ApplicationId)
		}
	} else {
		api.OAuth2PermissionScopes = nil
	}

	if d.HasChange("identifier_uris") {
		properties.IdentifierUris = tf.ExpandStringSlicePtr(d.Get("identifier_uris").(*pluginsdk.Set).List())
	}

	if d.HasChange("optional_claims") {
		properties.OptionalClaims = expandApplicationOptionalClaims(d.Get("optional_claims").([]interface{}))
	}

	if d.HasChange("required_resource_access") {
		properties.RequiredResourceAccess = expandApplicationRequiredResourceAccess(d.Get("required_resource_access").(*pluginsdk.Set).List())
	}

	properties.Api = api

	if _, err = client.UpdateApplication(ctx, *id, properties, application.DefaultUpdateApplicationOperationOptions()); err != nil {
		return tf.ErrorDiagF(err, "Could not update application with object ID: %q", id.ApplicationId)
	}

	if d.HasChange("oauth2_post_response_required") {
		// API bug: the v1.0 API does not recognize the `oauth2RequiredPostResponse` field, so set it using the beta API
		// See https://github.com/microsoftgraph/msgraph-metadata/issues/273
		if _, err := clientBeta.UpdateApplication(ctx, betaId, beta.Application{
			OAuth2RequirePostResponse: pointer.To(d.Get("oauth2_post_response_required").(bool)),
		}, applicationBeta.DefaultUpdateApplicationOperationOptions()); err != nil {
			return tf.ErrorDiagF(err, "Failed to set `oauth2_post_response_required` for %s", id)
		}
	}

	if d.HasChange("owners") {
		resp, err := ownerClient.ListOwners(ctx, *id, owner.DefaultListOwnersOperationOptions())
		if err != nil {
			return tf.ErrorDiagF(err, "Could not retrieve owners for application with object ID: %q", id.ApplicationId)
		}

		existingOwners := make([]string, 0)
		if resp.Model != nil {
			for _, o := range *resp.Model {
				existingOwners = append(existingOwners, pointer.From(o.DirectoryObject().Id))
			}
		}

		desiredOwners := *tf.ExpandStringSlicePtr(d.Get("owners").(*pluginsdk.Set).List())
		ownersForRemoval := tf.Difference(existingOwners, desiredOwners)
		ownersToAdd := tf.Difference(desiredOwners, existingOwners)

		for _, o := range ownersToAdd {
			request := stable.ReferenceCreate{
				ODataId: pointer.To(client.Client.BaseUri + stable.NewDirectoryObjectID(o).ID()),
			}
			if _, err = ownerClient.AddOwnerRef(ctx, *id, request, owner.DefaultAddOwnerRefOperationOptions()); err != nil {
				return tf.ErrorDiagF(err, "Could not add owners to application with object ID: %q", id.ApplicationId)
			}
		}

		for _, o := range ownersForRemoval {
			if _, err = ownerClient.RemoveOwnerRef(ctx, stable.NewApplicationIdOwnerID(id.ApplicationId, o), owner.DefaultRemoveOwnerRefOperationOptions()); err != nil {
				return tf.ErrorDiagF(err, "Could not add owners to application with object ID: %q", id.ApplicationId)
			}
		}
	}

	// Upload the application image
	if imageContentType != "" && len(imageData) > 0 {
		if _, err = logoClient.SetLogo(ctx, *id, imageData, logo.SetLogoOperationOptions{
			ContentType: imageContentType,
		}); err != nil {
			return tf.ErrorDiagF(err, "Could not upload logo image for application with object ID: %q", id.ApplicationId)
		}
	}

	return applicationResourceRead(ctx, d, meta)
}
