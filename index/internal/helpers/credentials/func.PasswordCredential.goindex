package github.com/hashicorp/terraform-provider-azuread/internal/helpers/credentials
import (
	"bytes"
	"crypto/sha1"
	"crypto/x509"
	"encoding/base64"
	"encoding/hex"
	"encoding/pem"
	"fmt"
	"strings"
	"time"

	"github.com/hashicorp/go-azure-sdk/microsoft-graph/common-types/stable"
	"github.com/hashicorp/go-azure-sdk/sdk/nullable"
	"github.com/hashicorp/go-uuid"
	"github.com/hashicorp/terraform-provider-azuread/internal/helpers/tf/pluginsdk"
)
func PasswordCredential(in map[string]interface{}) (*stable.PasswordCredential, error) {
	credential := stable.PasswordCredential{}

	if v, ok := in["display_name"]; ok {
		credential.DisplayName = nullable.Value(v.(string))
	}

	if v, ok := in["start_date"]; ok && v.(string) != "" {
		startDate, err := time.Parse(time.RFC3339, v.(string))
		if err != nil {
			return nil, CredentialError{str: fmt.Sprintf("Unable to parse the provided start date %q: %+v", v, err), attr: "start_date"}
		}
		credential.StartDateTime = nullable.Value(startDate.Format(time.RFC3339))
	}

	if v, ok := in["end_date"]; ok && v.(string) != "" {
		var err error
		expiry, err := time.Parse(time.RFC3339, v.(string))
		if err != nil {
			return nil, CredentialError{str: fmt.Sprintf("Unable to parse the provided end date %q: %+v", v, err), attr: "end_date"}
		}

		credential.EndDateTime = nullable.Value(expiry.Format(time.RFC3339))
	}

	if v, ok := in["key_id"]; ok && v.(string) != "" {
		credential.KeyId = nullable.Value(v.(string))
	}

	if v, ok := in["value"]; ok && v.(string) != "" {
		credential.SecretText = nullable.Value(v.(string))
	}

	return &credential, nil
}
